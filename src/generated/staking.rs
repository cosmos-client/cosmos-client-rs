// This file is generated by rust-protobuf 2.20.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `cosmos/staking/v1beta1/staking.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_20_0;

#[derive(PartialEq,Clone,Default)]
pub struct HistoricalInfo {
    // message fields
    pub header: ::protobuf::SingularPtrField<super::types::Header>,
    pub valset: ::protobuf::RepeatedField<Validator>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HistoricalInfo {
    fn default() -> &'a HistoricalInfo {
        <HistoricalInfo as ::protobuf::Message>::default_instance()
    }
}

impl HistoricalInfo {
    pub fn new() -> HistoricalInfo {
        ::std::default::Default::default()
    }

    // .tendermint.types.Header header = 1;


    pub fn get_header(&self) -> &super::types::Header {
        self.header.as_ref().unwrap_or_else(|| <super::types::Header as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: super::types::Header) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut super::types::Header {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> super::types::Header {
        self.header.take().unwrap_or_else(|| super::types::Header::new())
    }

    // repeated .cosmos.staking.v1beta1.Validator valset = 2;


    pub fn get_valset(&self) -> &[Validator] {
        &self.valset
    }
    pub fn clear_valset(&mut self) {
        self.valset.clear();
    }

    // Param is passed by value, moved
    pub fn set_valset(&mut self, v: ::protobuf::RepeatedField<Validator>) {
        self.valset = v;
    }

    // Mutable pointer to the field.
    pub fn mut_valset(&mut self) -> &mut ::protobuf::RepeatedField<Validator> {
        &mut self.valset
    }

    // Take field
    pub fn take_valset(&mut self) -> ::protobuf::RepeatedField<Validator> {
        ::std::mem::replace(&mut self.valset, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for HistoricalInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.valset {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.valset)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.valset {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.valset {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HistoricalInfo {
        HistoricalInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::types::Header>>(
                "header",
                |m: &HistoricalInfo| { &m.header },
                |m: &mut HistoricalInfo| { &mut m.header },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Validator>>(
                "valset",
                |m: &HistoricalInfo| { &m.valset },
                |m: &mut HistoricalInfo| { &mut m.valset },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HistoricalInfo>(
                "HistoricalInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HistoricalInfo {
        static instance: ::protobuf::rt::LazyV2<HistoricalInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HistoricalInfo::new)
    }
}

impl ::protobuf::Clear for HistoricalInfo {
    fn clear(&mut self) {
        self.header.clear();
        self.valset.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HistoricalInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HistoricalInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommissionRates {
    // message fields
    pub rate: ::std::string::String,
    pub max_rate: ::std::string::String,
    pub max_change_rate: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommissionRates {
    fn default() -> &'a CommissionRates {
        <CommissionRates as ::protobuf::Message>::default_instance()
    }
}

impl CommissionRates {
    pub fn new() -> CommissionRates {
        ::std::default::Default::default()
    }

    // string rate = 1;


    pub fn get_rate(&self) -> &str {
        &self.rate
    }
    pub fn clear_rate(&mut self) {
        self.rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_rate(&mut self, v: ::std::string::String) {
        self.rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rate(&mut self) -> &mut ::std::string::String {
        &mut self.rate
    }

    // Take field
    pub fn take_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.rate, ::std::string::String::new())
    }

    // string max_rate = 2;


    pub fn get_max_rate(&self) -> &str {
        &self.max_rate
    }
    pub fn clear_max_rate(&mut self) {
        self.max_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_max_rate(&mut self, v: ::std::string::String) {
        self.max_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_max_rate(&mut self) -> &mut ::std::string::String {
        &mut self.max_rate
    }

    // Take field
    pub fn take_max_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.max_rate, ::std::string::String::new())
    }

    // string max_change_rate = 3;


    pub fn get_max_change_rate(&self) -> &str {
        &self.max_change_rate
    }
    pub fn clear_max_change_rate(&mut self) {
        self.max_change_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_max_change_rate(&mut self, v: ::std::string::String) {
        self.max_change_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_max_change_rate(&mut self) -> &mut ::std::string::String {
        &mut self.max_change_rate
    }

    // Take field
    pub fn take_max_change_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.max_change_rate, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CommissionRates {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.rate)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.max_rate)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.max_change_rate)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.rate.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.rate);
        }
        if !self.max_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.max_rate);
        }
        if !self.max_change_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.max_change_rate);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.rate.is_empty() {
            os.write_string(1, &self.rate)?;
        }
        if !self.max_rate.is_empty() {
            os.write_string(2, &self.max_rate)?;
        }
        if !self.max_change_rate.is_empty() {
            os.write_string(3, &self.max_change_rate)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommissionRates {
        CommissionRates::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "rate",
                |m: &CommissionRates| { &m.rate },
                |m: &mut CommissionRates| { &mut m.rate },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "max_rate",
                |m: &CommissionRates| { &m.max_rate },
                |m: &mut CommissionRates| { &mut m.max_rate },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "max_change_rate",
                |m: &CommissionRates| { &m.max_change_rate },
                |m: &mut CommissionRates| { &mut m.max_change_rate },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CommissionRates>(
                "CommissionRates",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CommissionRates {
        static instance: ::protobuf::rt::LazyV2<CommissionRates> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommissionRates::new)
    }
}

impl ::protobuf::Clear for CommissionRates {
    fn clear(&mut self) {
        self.rate.clear();
        self.max_rate.clear();
        self.max_change_rate.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommissionRates {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommissionRates {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Commission {
    // message fields
    pub commission_rates: ::protobuf::SingularPtrField<CommissionRates>,
    pub update_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Commission {
    fn default() -> &'a Commission {
        <Commission as ::protobuf::Message>::default_instance()
    }
}

impl Commission {
    pub fn new() -> Commission {
        ::std::default::Default::default()
    }

    // .cosmos.staking.v1beta1.CommissionRates commission_rates = 1;


    pub fn get_commission_rates(&self) -> &CommissionRates {
        self.commission_rates.as_ref().unwrap_or_else(|| <CommissionRates as ::protobuf::Message>::default_instance())
    }
    pub fn clear_commission_rates(&mut self) {
        self.commission_rates.clear();
    }

    pub fn has_commission_rates(&self) -> bool {
        self.commission_rates.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commission_rates(&mut self, v: CommissionRates) {
        self.commission_rates = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commission_rates(&mut self) -> &mut CommissionRates {
        if self.commission_rates.is_none() {
            self.commission_rates.set_default();
        }
        self.commission_rates.as_mut().unwrap()
    }

    // Take field
    pub fn take_commission_rates(&mut self) -> CommissionRates {
        self.commission_rates.take().unwrap_or_else(|| CommissionRates::new())
    }

    // .google.protobuf.Timestamp update_time = 2;


    pub fn get_update_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.update_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_update_time(&mut self) {
        self.update_time.clear();
    }

    pub fn has_update_time(&self) -> bool {
        self.update_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.update_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.update_time.is_none() {
            self.update_time.set_default();
        }
        self.update_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.update_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for Commission {
    fn is_initialized(&self) -> bool {
        for v in &self.commission_rates {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commission_rates)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_time)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.commission_rates.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.commission_rates.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update_time.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Commission {
        Commission::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommissionRates>>(
                "commission_rates",
                |m: &Commission| { &m.commission_rates },
                |m: &mut Commission| { &mut m.commission_rates },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "update_time",
                |m: &Commission| { &m.update_time },
                |m: &mut Commission| { &mut m.update_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Commission>(
                "Commission",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Commission {
        static instance: ::protobuf::rt::LazyV2<Commission> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Commission::new)
    }
}

impl ::protobuf::Clear for Commission {
    fn clear(&mut self) {
        self.commission_rates.clear();
        self.update_time.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Commission {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Commission {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Description {
    // message fields
    pub moniker: ::std::string::String,
    pub identity: ::std::string::String,
    pub website: ::std::string::String,
    pub security_contact: ::std::string::String,
    pub details: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Description {
    fn default() -> &'a Description {
        <Description as ::protobuf::Message>::default_instance()
    }
}

impl Description {
    pub fn new() -> Description {
        ::std::default::Default::default()
    }

    // string moniker = 1;


    pub fn get_moniker(&self) -> &str {
        &self.moniker
    }
    pub fn clear_moniker(&mut self) {
        self.moniker.clear();
    }

    // Param is passed by value, moved
    pub fn set_moniker(&mut self, v: ::std::string::String) {
        self.moniker = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_moniker(&mut self) -> &mut ::std::string::String {
        &mut self.moniker
    }

    // Take field
    pub fn take_moniker(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.moniker, ::std::string::String::new())
    }

    // string identity = 2;


    pub fn get_identity(&self) -> &str {
        &self.identity
    }
    pub fn clear_identity(&mut self) {
        self.identity.clear();
    }

    // Param is passed by value, moved
    pub fn set_identity(&mut self, v: ::std::string::String) {
        self.identity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identity(&mut self) -> &mut ::std::string::String {
        &mut self.identity
    }

    // Take field
    pub fn take_identity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.identity, ::std::string::String::new())
    }

    // string website = 3;


    pub fn get_website(&self) -> &str {
        &self.website
    }
    pub fn clear_website(&mut self) {
        self.website.clear();
    }

    // Param is passed by value, moved
    pub fn set_website(&mut self, v: ::std::string::String) {
        self.website = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_website(&mut self) -> &mut ::std::string::String {
        &mut self.website
    }

    // Take field
    pub fn take_website(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.website, ::std::string::String::new())
    }

    // string security_contact = 4;


    pub fn get_security_contact(&self) -> &str {
        &self.security_contact
    }
    pub fn clear_security_contact(&mut self) {
        self.security_contact.clear();
    }

    // Param is passed by value, moved
    pub fn set_security_contact(&mut self, v: ::std::string::String) {
        self.security_contact = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_security_contact(&mut self) -> &mut ::std::string::String {
        &mut self.security_contact
    }

    // Take field
    pub fn take_security_contact(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.security_contact, ::std::string::String::new())
    }

    // string details = 5;


    pub fn get_details(&self) -> &str {
        &self.details
    }
    pub fn clear_details(&mut self) {
        self.details.clear();
    }

    // Param is passed by value, moved
    pub fn set_details(&mut self, v: ::std::string::String) {
        self.details = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_details(&mut self) -> &mut ::std::string::String {
        &mut self.details
    }

    // Take field
    pub fn take_details(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.details, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Description {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.moniker)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.identity)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.website)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.security_contact)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.details)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.moniker.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.moniker);
        }
        if !self.identity.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.identity);
        }
        if !self.website.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.website);
        }
        if !self.security_contact.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.security_contact);
        }
        if !self.details.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.details);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.moniker.is_empty() {
            os.write_string(1, &self.moniker)?;
        }
        if !self.identity.is_empty() {
            os.write_string(2, &self.identity)?;
        }
        if !self.website.is_empty() {
            os.write_string(3, &self.website)?;
        }
        if !self.security_contact.is_empty() {
            os.write_string(4, &self.security_contact)?;
        }
        if !self.details.is_empty() {
            os.write_string(5, &self.details)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Description {
        Description::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "moniker",
                |m: &Description| { &m.moniker },
                |m: &mut Description| { &mut m.moniker },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "identity",
                |m: &Description| { &m.identity },
                |m: &mut Description| { &mut m.identity },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "website",
                |m: &Description| { &m.website },
                |m: &mut Description| { &mut m.website },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "security_contact",
                |m: &Description| { &m.security_contact },
                |m: &mut Description| { &mut m.security_contact },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "details",
                |m: &Description| { &m.details },
                |m: &mut Description| { &mut m.details },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Description>(
                "Description",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Description {
        static instance: ::protobuf::rt::LazyV2<Description> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Description::new)
    }
}

impl ::protobuf::Clear for Description {
    fn clear(&mut self) {
        self.moniker.clear();
        self.identity.clear();
        self.website.clear();
        self.security_contact.clear();
        self.details.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Description {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Description {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Validator {
    // message fields
    pub operator_address: ::std::string::String,
    pub consensus_pubkey: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    pub jailed: bool,
    pub status: BondStatus,
    pub tokens: ::std::string::String,
    pub delegator_shares: ::std::string::String,
    pub description: ::protobuf::SingularPtrField<Description>,
    pub unbonding_height: i64,
    pub unbonding_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub commission: ::protobuf::SingularPtrField<Commission>,
    pub min_self_delegation: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Validator {
    fn default() -> &'a Validator {
        <Validator as ::protobuf::Message>::default_instance()
    }
}

impl Validator {
    pub fn new() -> Validator {
        ::std::default::Default::default()
    }

    // string operator_address = 1;


    pub fn get_operator_address(&self) -> &str {
        &self.operator_address
    }
    pub fn clear_operator_address(&mut self) {
        self.operator_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_operator_address(&mut self, v: ::std::string::String) {
        self.operator_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operator_address(&mut self) -> &mut ::std::string::String {
        &mut self.operator_address
    }

    // Take field
    pub fn take_operator_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.operator_address, ::std::string::String::new())
    }

    // .google.protobuf.Any consensus_pubkey = 2;


    pub fn get_consensus_pubkey(&self) -> &::protobuf::well_known_types::Any {
        self.consensus_pubkey.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Any as ::protobuf::Message>::default_instance())
    }
    pub fn clear_consensus_pubkey(&mut self) {
        self.consensus_pubkey.clear();
    }

    pub fn has_consensus_pubkey(&self) -> bool {
        self.consensus_pubkey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consensus_pubkey(&mut self, v: ::protobuf::well_known_types::Any) {
        self.consensus_pubkey = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_consensus_pubkey(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.consensus_pubkey.is_none() {
            self.consensus_pubkey.set_default();
        }
        self.consensus_pubkey.as_mut().unwrap()
    }

    // Take field
    pub fn take_consensus_pubkey(&mut self) -> ::protobuf::well_known_types::Any {
        self.consensus_pubkey.take().unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }

    // bool jailed = 3;


    pub fn get_jailed(&self) -> bool {
        self.jailed
    }
    pub fn clear_jailed(&mut self) {
        self.jailed = false;
    }

    // Param is passed by value, moved
    pub fn set_jailed(&mut self, v: bool) {
        self.jailed = v;
    }

    // .cosmos.staking.v1beta1.BondStatus status = 4;


    pub fn get_status(&self) -> BondStatus {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = BondStatus::BOND_STATUS_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: BondStatus) {
        self.status = v;
    }

    // string tokens = 5;


    pub fn get_tokens(&self) -> &str {
        &self.tokens
    }
    pub fn clear_tokens(&mut self) {
        self.tokens.clear();
    }

    // Param is passed by value, moved
    pub fn set_tokens(&mut self, v: ::std::string::String) {
        self.tokens = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tokens(&mut self) -> &mut ::std::string::String {
        &mut self.tokens
    }

    // Take field
    pub fn take_tokens(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tokens, ::std::string::String::new())
    }

    // string delegator_shares = 6;


    pub fn get_delegator_shares(&self) -> &str {
        &self.delegator_shares
    }
    pub fn clear_delegator_shares(&mut self) {
        self.delegator_shares.clear();
    }

    // Param is passed by value, moved
    pub fn set_delegator_shares(&mut self, v: ::std::string::String) {
        self.delegator_shares = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_delegator_shares(&mut self) -> &mut ::std::string::String {
        &mut self.delegator_shares
    }

    // Take field
    pub fn take_delegator_shares(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.delegator_shares, ::std::string::String::new())
    }

    // .cosmos.staking.v1beta1.Description description = 7;


    pub fn get_description(&self) -> &Description {
        self.description.as_ref().unwrap_or_else(|| <Description as ::protobuf::Message>::default_instance())
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: Description) {
        self.description = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut Description {
        if self.description.is_none() {
            self.description.set_default();
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> Description {
        self.description.take().unwrap_or_else(|| Description::new())
    }

    // int64 unbonding_height = 8;


    pub fn get_unbonding_height(&self) -> i64 {
        self.unbonding_height
    }
    pub fn clear_unbonding_height(&mut self) {
        self.unbonding_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_unbonding_height(&mut self, v: i64) {
        self.unbonding_height = v;
    }

    // .google.protobuf.Timestamp unbonding_time = 9;


    pub fn get_unbonding_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.unbonding_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_unbonding_time(&mut self) {
        self.unbonding_time.clear();
    }

    pub fn has_unbonding_time(&self) -> bool {
        self.unbonding_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unbonding_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.unbonding_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unbonding_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.unbonding_time.is_none() {
            self.unbonding_time.set_default();
        }
        self.unbonding_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_unbonding_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.unbonding_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .cosmos.staking.v1beta1.Commission commission = 10;


    pub fn get_commission(&self) -> &Commission {
        self.commission.as_ref().unwrap_or_else(|| <Commission as ::protobuf::Message>::default_instance())
    }
    pub fn clear_commission(&mut self) {
        self.commission.clear();
    }

    pub fn has_commission(&self) -> bool {
        self.commission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commission(&mut self, v: Commission) {
        self.commission = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commission(&mut self) -> &mut Commission {
        if self.commission.is_none() {
            self.commission.set_default();
        }
        self.commission.as_mut().unwrap()
    }

    // Take field
    pub fn take_commission(&mut self) -> Commission {
        self.commission.take().unwrap_or_else(|| Commission::new())
    }

    // string min_self_delegation = 11;


    pub fn get_min_self_delegation(&self) -> &str {
        &self.min_self_delegation
    }
    pub fn clear_min_self_delegation(&mut self) {
        self.min_self_delegation.clear();
    }

    // Param is passed by value, moved
    pub fn set_min_self_delegation(&mut self, v: ::std::string::String) {
        self.min_self_delegation = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_min_self_delegation(&mut self) -> &mut ::std::string::String {
        &mut self.min_self_delegation
    }

    // Take field
    pub fn take_min_self_delegation(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.min_self_delegation, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Validator {
    fn is_initialized(&self) -> bool {
        for v in &self.consensus_pubkey {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.description {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unbonding_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.commission {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.operator_address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.consensus_pubkey)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.jailed = tmp;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tokens)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.delegator_shares)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.description)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.unbonding_height = tmp;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unbonding_time)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commission)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.min_self_delegation)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.operator_address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.operator_address);
        }
        if let Some(ref v) = self.consensus_pubkey.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.jailed != false {
            my_size += 2;
        }
        if self.status != BondStatus::BOND_STATUS_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(4, self.status);
        }
        if !self.tokens.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.tokens);
        }
        if !self.delegator_shares.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.delegator_shares);
        }
        if let Some(ref v) = self.description.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.unbonding_height != 0 {
            my_size += ::protobuf::rt::value_size(8, self.unbonding_height, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.unbonding_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.commission.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.min_self_delegation.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.min_self_delegation);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.operator_address.is_empty() {
            os.write_string(1, &self.operator_address)?;
        }
        if let Some(ref v) = self.consensus_pubkey.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.jailed != false {
            os.write_bool(3, self.jailed)?;
        }
        if self.status != BondStatus::BOND_STATUS_UNSPECIFIED {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.status))?;
        }
        if !self.tokens.is_empty() {
            os.write_string(5, &self.tokens)?;
        }
        if !self.delegator_shares.is_empty() {
            os.write_string(6, &self.delegator_shares)?;
        }
        if let Some(ref v) = self.description.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.unbonding_height != 0 {
            os.write_int64(8, self.unbonding_height)?;
        }
        if let Some(ref v) = self.unbonding_time.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.commission.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.min_self_delegation.is_empty() {
            os.write_string(11, &self.min_self_delegation)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Validator {
        Validator::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "operator_address",
                |m: &Validator| { &m.operator_address },
                |m: &mut Validator| { &mut m.operator_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                "consensus_pubkey",
                |m: &Validator| { &m.consensus_pubkey },
                |m: &mut Validator| { &mut m.consensus_pubkey },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "jailed",
                |m: &Validator| { &m.jailed },
                |m: &mut Validator| { &mut m.jailed },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<BondStatus>>(
                "status",
                |m: &Validator| { &m.status },
                |m: &mut Validator| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tokens",
                |m: &Validator| { &m.tokens },
                |m: &mut Validator| { &mut m.tokens },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "delegator_shares",
                |m: &Validator| { &m.delegator_shares },
                |m: &mut Validator| { &mut m.delegator_shares },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Description>>(
                "description",
                |m: &Validator| { &m.description },
                |m: &mut Validator| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "unbonding_height",
                |m: &Validator| { &m.unbonding_height },
                |m: &mut Validator| { &mut m.unbonding_height },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "unbonding_time",
                |m: &Validator| { &m.unbonding_time },
                |m: &mut Validator| { &mut m.unbonding_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Commission>>(
                "commission",
                |m: &Validator| { &m.commission },
                |m: &mut Validator| { &mut m.commission },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "min_self_delegation",
                |m: &Validator| { &m.min_self_delegation },
                |m: &mut Validator| { &mut m.min_self_delegation },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Validator>(
                "Validator",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Validator {
        static instance: ::protobuf::rt::LazyV2<Validator> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Validator::new)
    }
}

impl ::protobuf::Clear for Validator {
    fn clear(&mut self) {
        self.operator_address.clear();
        self.consensus_pubkey.clear();
        self.jailed = false;
        self.status = BondStatus::BOND_STATUS_UNSPECIFIED;
        self.tokens.clear();
        self.delegator_shares.clear();
        self.description.clear();
        self.unbonding_height = 0;
        self.unbonding_time.clear();
        self.commission.clear();
        self.min_self_delegation.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Validator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Validator {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ValAddresses {
    // message fields
    pub addresses: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ValAddresses {
    fn default() -> &'a ValAddresses {
        <ValAddresses as ::protobuf::Message>::default_instance()
    }
}

impl ValAddresses {
    pub fn new() -> ValAddresses {
        ::std::default::Default::default()
    }

    // repeated string addresses = 1;


    pub fn get_addresses(&self) -> &[::std::string::String] {
        &self.addresses
    }
    pub fn clear_addresses(&mut self) {
        self.addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_addresses(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_addresses(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.addresses
    }

    // Take field
    pub fn take_addresses(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.addresses, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ValAddresses {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.addresses)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.addresses {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.addresses {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ValAddresses {
        ValAddresses::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "addresses",
                |m: &ValAddresses| { &m.addresses },
                |m: &mut ValAddresses| { &mut m.addresses },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ValAddresses>(
                "ValAddresses",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ValAddresses {
        static instance: ::protobuf::rt::LazyV2<ValAddresses> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ValAddresses::new)
    }
}

impl ::protobuf::Clear for ValAddresses {
    fn clear(&mut self) {
        self.addresses.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ValAddresses {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValAddresses {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DVPair {
    // message fields
    pub delegator_address: ::std::string::String,
    pub validator_address: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DVPair {
    fn default() -> &'a DVPair {
        <DVPair as ::protobuf::Message>::default_instance()
    }
}

impl DVPair {
    pub fn new() -> DVPair {
        ::std::default::Default::default()
    }

    // string delegator_address = 1;


    pub fn get_delegator_address(&self) -> &str {
        &self.delegator_address
    }
    pub fn clear_delegator_address(&mut self) {
        self.delegator_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_delegator_address(&mut self, v: ::std::string::String) {
        self.delegator_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_delegator_address(&mut self) -> &mut ::std::string::String {
        &mut self.delegator_address
    }

    // Take field
    pub fn take_delegator_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.delegator_address, ::std::string::String::new())
    }

    // string validator_address = 2;


    pub fn get_validator_address(&self) -> &str {
        &self.validator_address
    }
    pub fn clear_validator_address(&mut self) {
        self.validator_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_validator_address(&mut self, v: ::std::string::String) {
        self.validator_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_validator_address(&mut self) -> &mut ::std::string::String {
        &mut self.validator_address
    }

    // Take field
    pub fn take_validator_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.validator_address, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DVPair {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.delegator_address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.validator_address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.delegator_address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.delegator_address);
        }
        if !self.validator_address.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.validator_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.delegator_address.is_empty() {
            os.write_string(1, &self.delegator_address)?;
        }
        if !self.validator_address.is_empty() {
            os.write_string(2, &self.validator_address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DVPair {
        DVPair::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "delegator_address",
                |m: &DVPair| { &m.delegator_address },
                |m: &mut DVPair| { &mut m.delegator_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "validator_address",
                |m: &DVPair| { &m.validator_address },
                |m: &mut DVPair| { &mut m.validator_address },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DVPair>(
                "DVPair",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DVPair {
        static instance: ::protobuf::rt::LazyV2<DVPair> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DVPair::new)
    }
}

impl ::protobuf::Clear for DVPair {
    fn clear(&mut self) {
        self.delegator_address.clear();
        self.validator_address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DVPair {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DVPair {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DVPairs {
    // message fields
    pub pairs: ::protobuf::RepeatedField<DVPair>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DVPairs {
    fn default() -> &'a DVPairs {
        <DVPairs as ::protobuf::Message>::default_instance()
    }
}

impl DVPairs {
    pub fn new() -> DVPairs {
        ::std::default::Default::default()
    }

    // repeated .cosmos.staking.v1beta1.DVPair pairs = 1;


    pub fn get_pairs(&self) -> &[DVPair] {
        &self.pairs
    }
    pub fn clear_pairs(&mut self) {
        self.pairs.clear();
    }

    // Param is passed by value, moved
    pub fn set_pairs(&mut self, v: ::protobuf::RepeatedField<DVPair>) {
        self.pairs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pairs(&mut self) -> &mut ::protobuf::RepeatedField<DVPair> {
        &mut self.pairs
    }

    // Take field
    pub fn take_pairs(&mut self) -> ::protobuf::RepeatedField<DVPair> {
        ::std::mem::replace(&mut self.pairs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DVPairs {
    fn is_initialized(&self) -> bool {
        for v in &self.pairs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pairs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.pairs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.pairs {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DVPairs {
        DVPairs::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DVPair>>(
                "pairs",
                |m: &DVPairs| { &m.pairs },
                |m: &mut DVPairs| { &mut m.pairs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DVPairs>(
                "DVPairs",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DVPairs {
        static instance: ::protobuf::rt::LazyV2<DVPairs> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DVPairs::new)
    }
}

impl ::protobuf::Clear for DVPairs {
    fn clear(&mut self) {
        self.pairs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DVPairs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DVPairs {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DVVTriplet {
    // message fields
    pub delegator_address: ::std::string::String,
    pub validator_src_address: ::std::string::String,
    pub validator_dst_address: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DVVTriplet {
    fn default() -> &'a DVVTriplet {
        <DVVTriplet as ::protobuf::Message>::default_instance()
    }
}

impl DVVTriplet {
    pub fn new() -> DVVTriplet {
        ::std::default::Default::default()
    }

    // string delegator_address = 1;


    pub fn get_delegator_address(&self) -> &str {
        &self.delegator_address
    }
    pub fn clear_delegator_address(&mut self) {
        self.delegator_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_delegator_address(&mut self, v: ::std::string::String) {
        self.delegator_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_delegator_address(&mut self) -> &mut ::std::string::String {
        &mut self.delegator_address
    }

    // Take field
    pub fn take_delegator_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.delegator_address, ::std::string::String::new())
    }

    // string validator_src_address = 2;


    pub fn get_validator_src_address(&self) -> &str {
        &self.validator_src_address
    }
    pub fn clear_validator_src_address(&mut self) {
        self.validator_src_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_validator_src_address(&mut self, v: ::std::string::String) {
        self.validator_src_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_validator_src_address(&mut self) -> &mut ::std::string::String {
        &mut self.validator_src_address
    }

    // Take field
    pub fn take_validator_src_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.validator_src_address, ::std::string::String::new())
    }

    // string validator_dst_address = 3;


    pub fn get_validator_dst_address(&self) -> &str {
        &self.validator_dst_address
    }
    pub fn clear_validator_dst_address(&mut self) {
        self.validator_dst_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_validator_dst_address(&mut self, v: ::std::string::String) {
        self.validator_dst_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_validator_dst_address(&mut self) -> &mut ::std::string::String {
        &mut self.validator_dst_address
    }

    // Take field
    pub fn take_validator_dst_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.validator_dst_address, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DVVTriplet {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.delegator_address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.validator_src_address)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.validator_dst_address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.delegator_address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.delegator_address);
        }
        if !self.validator_src_address.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.validator_src_address);
        }
        if !self.validator_dst_address.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.validator_dst_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.delegator_address.is_empty() {
            os.write_string(1, &self.delegator_address)?;
        }
        if !self.validator_src_address.is_empty() {
            os.write_string(2, &self.validator_src_address)?;
        }
        if !self.validator_dst_address.is_empty() {
            os.write_string(3, &self.validator_dst_address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DVVTriplet {
        DVVTriplet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "delegator_address",
                |m: &DVVTriplet| { &m.delegator_address },
                |m: &mut DVVTriplet| { &mut m.delegator_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "validator_src_address",
                |m: &DVVTriplet| { &m.validator_src_address },
                |m: &mut DVVTriplet| { &mut m.validator_src_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "validator_dst_address",
                |m: &DVVTriplet| { &m.validator_dst_address },
                |m: &mut DVVTriplet| { &mut m.validator_dst_address },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DVVTriplet>(
                "DVVTriplet",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DVVTriplet {
        static instance: ::protobuf::rt::LazyV2<DVVTriplet> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DVVTriplet::new)
    }
}

impl ::protobuf::Clear for DVVTriplet {
    fn clear(&mut self) {
        self.delegator_address.clear();
        self.validator_src_address.clear();
        self.validator_dst_address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DVVTriplet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DVVTriplet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DVVTriplets {
    // message fields
    pub triplets: ::protobuf::RepeatedField<DVVTriplet>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DVVTriplets {
    fn default() -> &'a DVVTriplets {
        <DVVTriplets as ::protobuf::Message>::default_instance()
    }
}

impl DVVTriplets {
    pub fn new() -> DVVTriplets {
        ::std::default::Default::default()
    }

    // repeated .cosmos.staking.v1beta1.DVVTriplet triplets = 1;


    pub fn get_triplets(&self) -> &[DVVTriplet] {
        &self.triplets
    }
    pub fn clear_triplets(&mut self) {
        self.triplets.clear();
    }

    // Param is passed by value, moved
    pub fn set_triplets(&mut self, v: ::protobuf::RepeatedField<DVVTriplet>) {
        self.triplets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_triplets(&mut self) -> &mut ::protobuf::RepeatedField<DVVTriplet> {
        &mut self.triplets
    }

    // Take field
    pub fn take_triplets(&mut self) -> ::protobuf::RepeatedField<DVVTriplet> {
        ::std::mem::replace(&mut self.triplets, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DVVTriplets {
    fn is_initialized(&self) -> bool {
        for v in &self.triplets {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.triplets)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.triplets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.triplets {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DVVTriplets {
        DVVTriplets::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DVVTriplet>>(
                "triplets",
                |m: &DVVTriplets| { &m.triplets },
                |m: &mut DVVTriplets| { &mut m.triplets },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DVVTriplets>(
                "DVVTriplets",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DVVTriplets {
        static instance: ::protobuf::rt::LazyV2<DVVTriplets> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DVVTriplets::new)
    }
}

impl ::protobuf::Clear for DVVTriplets {
    fn clear(&mut self) {
        self.triplets.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DVVTriplets {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DVVTriplets {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Delegation {
    // message fields
    pub delegator_address: ::std::string::String,
    pub validator_address: ::std::string::String,
    pub shares: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Delegation {
    fn default() -> &'a Delegation {
        <Delegation as ::protobuf::Message>::default_instance()
    }
}

impl Delegation {
    pub fn new() -> Delegation {
        ::std::default::Default::default()
    }

    // string delegator_address = 1;


    pub fn get_delegator_address(&self) -> &str {
        &self.delegator_address
    }
    pub fn clear_delegator_address(&mut self) {
        self.delegator_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_delegator_address(&mut self, v: ::std::string::String) {
        self.delegator_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_delegator_address(&mut self) -> &mut ::std::string::String {
        &mut self.delegator_address
    }

    // Take field
    pub fn take_delegator_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.delegator_address, ::std::string::String::new())
    }

    // string validator_address = 2;


    pub fn get_validator_address(&self) -> &str {
        &self.validator_address
    }
    pub fn clear_validator_address(&mut self) {
        self.validator_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_validator_address(&mut self, v: ::std::string::String) {
        self.validator_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_validator_address(&mut self) -> &mut ::std::string::String {
        &mut self.validator_address
    }

    // Take field
    pub fn take_validator_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.validator_address, ::std::string::String::new())
    }

    // string shares = 3;


    pub fn get_shares(&self) -> &str {
        &self.shares
    }
    pub fn clear_shares(&mut self) {
        self.shares.clear();
    }

    // Param is passed by value, moved
    pub fn set_shares(&mut self, v: ::std::string::String) {
        self.shares = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shares(&mut self) -> &mut ::std::string::String {
        &mut self.shares
    }

    // Take field
    pub fn take_shares(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.shares, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Delegation {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.delegator_address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.validator_address)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.shares)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.delegator_address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.delegator_address);
        }
        if !self.validator_address.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.validator_address);
        }
        if !self.shares.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.shares);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.delegator_address.is_empty() {
            os.write_string(1, &self.delegator_address)?;
        }
        if !self.validator_address.is_empty() {
            os.write_string(2, &self.validator_address)?;
        }
        if !self.shares.is_empty() {
            os.write_string(3, &self.shares)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Delegation {
        Delegation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "delegator_address",
                |m: &Delegation| { &m.delegator_address },
                |m: &mut Delegation| { &mut m.delegator_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "validator_address",
                |m: &Delegation| { &m.validator_address },
                |m: &mut Delegation| { &mut m.validator_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "shares",
                |m: &Delegation| { &m.shares },
                |m: &mut Delegation| { &mut m.shares },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Delegation>(
                "Delegation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Delegation {
        static instance: ::protobuf::rt::LazyV2<Delegation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Delegation::new)
    }
}

impl ::protobuf::Clear for Delegation {
    fn clear(&mut self) {
        self.delegator_address.clear();
        self.validator_address.clear();
        self.shares.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Delegation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Delegation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UnbondingDelegation {
    // message fields
    pub delegator_address: ::std::string::String,
    pub validator_address: ::std::string::String,
    pub entries: ::protobuf::RepeatedField<UnbondingDelegationEntry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UnbondingDelegation {
    fn default() -> &'a UnbondingDelegation {
        <UnbondingDelegation as ::protobuf::Message>::default_instance()
    }
}

impl UnbondingDelegation {
    pub fn new() -> UnbondingDelegation {
        ::std::default::Default::default()
    }

    // string delegator_address = 1;


    pub fn get_delegator_address(&self) -> &str {
        &self.delegator_address
    }
    pub fn clear_delegator_address(&mut self) {
        self.delegator_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_delegator_address(&mut self, v: ::std::string::String) {
        self.delegator_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_delegator_address(&mut self) -> &mut ::std::string::String {
        &mut self.delegator_address
    }

    // Take field
    pub fn take_delegator_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.delegator_address, ::std::string::String::new())
    }

    // string validator_address = 2;


    pub fn get_validator_address(&self) -> &str {
        &self.validator_address
    }
    pub fn clear_validator_address(&mut self) {
        self.validator_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_validator_address(&mut self, v: ::std::string::String) {
        self.validator_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_validator_address(&mut self) -> &mut ::std::string::String {
        &mut self.validator_address
    }

    // Take field
    pub fn take_validator_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.validator_address, ::std::string::String::new())
    }

    // repeated .cosmos.staking.v1beta1.UnbondingDelegationEntry entries = 3;


    pub fn get_entries(&self) -> &[UnbondingDelegationEntry] {
        &self.entries
    }
    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::protobuf::RepeatedField<UnbondingDelegationEntry>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::protobuf::RepeatedField<UnbondingDelegationEntry> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::protobuf::RepeatedField<UnbondingDelegationEntry> {
        ::std::mem::replace(&mut self.entries, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for UnbondingDelegation {
    fn is_initialized(&self) -> bool {
        for v in &self.entries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.delegator_address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.validator_address)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entries)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.delegator_address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.delegator_address);
        }
        if !self.validator_address.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.validator_address);
        }
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.delegator_address.is_empty() {
            os.write_string(1, &self.delegator_address)?;
        }
        if !self.validator_address.is_empty() {
            os.write_string(2, &self.validator_address)?;
        }
        for v in &self.entries {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnbondingDelegation {
        UnbondingDelegation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "delegator_address",
                |m: &UnbondingDelegation| { &m.delegator_address },
                |m: &mut UnbondingDelegation| { &mut m.delegator_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "validator_address",
                |m: &UnbondingDelegation| { &m.validator_address },
                |m: &mut UnbondingDelegation| { &mut m.validator_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UnbondingDelegationEntry>>(
                "entries",
                |m: &UnbondingDelegation| { &m.entries },
                |m: &mut UnbondingDelegation| { &mut m.entries },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UnbondingDelegation>(
                "UnbondingDelegation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UnbondingDelegation {
        static instance: ::protobuf::rt::LazyV2<UnbondingDelegation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UnbondingDelegation::new)
    }
}

impl ::protobuf::Clear for UnbondingDelegation {
    fn clear(&mut self) {
        self.delegator_address.clear();
        self.validator_address.clear();
        self.entries.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnbondingDelegation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnbondingDelegation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UnbondingDelegationEntry {
    // message fields
    pub creation_height: i64,
    pub completion_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub initial_balance: ::std::string::String,
    pub balance: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UnbondingDelegationEntry {
    fn default() -> &'a UnbondingDelegationEntry {
        <UnbondingDelegationEntry as ::protobuf::Message>::default_instance()
    }
}

impl UnbondingDelegationEntry {
    pub fn new() -> UnbondingDelegationEntry {
        ::std::default::Default::default()
    }

    // int64 creation_height = 1;


    pub fn get_creation_height(&self) -> i64 {
        self.creation_height
    }
    pub fn clear_creation_height(&mut self) {
        self.creation_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_creation_height(&mut self, v: i64) {
        self.creation_height = v;
    }

    // .google.protobuf.Timestamp completion_time = 2;


    pub fn get_completion_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.completion_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_completion_time(&mut self) {
        self.completion_time.clear();
    }

    pub fn has_completion_time(&self) -> bool {
        self.completion_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_completion_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.completion_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_completion_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.completion_time.is_none() {
            self.completion_time.set_default();
        }
        self.completion_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_completion_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.completion_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // string initial_balance = 3;


    pub fn get_initial_balance(&self) -> &str {
        &self.initial_balance
    }
    pub fn clear_initial_balance(&mut self) {
        self.initial_balance.clear();
    }

    // Param is passed by value, moved
    pub fn set_initial_balance(&mut self, v: ::std::string::String) {
        self.initial_balance = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_initial_balance(&mut self) -> &mut ::std::string::String {
        &mut self.initial_balance
    }

    // Take field
    pub fn take_initial_balance(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.initial_balance, ::std::string::String::new())
    }

    // string balance = 4;


    pub fn get_balance(&self) -> &str {
        &self.balance
    }
    pub fn clear_balance(&mut self) {
        self.balance.clear();
    }

    // Param is passed by value, moved
    pub fn set_balance(&mut self, v: ::std::string::String) {
        self.balance = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_balance(&mut self) -> &mut ::std::string::String {
        &mut self.balance
    }

    // Take field
    pub fn take_balance(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.balance, ::std::string::String::new())
    }
}

impl ::protobuf::Message for UnbondingDelegationEntry {
    fn is_initialized(&self) -> bool {
        for v in &self.completion_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.creation_height = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.completion_time)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.initial_balance)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.balance)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.creation_height != 0 {
            my_size += ::protobuf::rt::value_size(1, self.creation_height, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.completion_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.initial_balance.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.initial_balance);
        }
        if !self.balance.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.balance);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.creation_height != 0 {
            os.write_int64(1, self.creation_height)?;
        }
        if let Some(ref v) = self.completion_time.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.initial_balance.is_empty() {
            os.write_string(3, &self.initial_balance)?;
        }
        if !self.balance.is_empty() {
            os.write_string(4, &self.balance)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnbondingDelegationEntry {
        UnbondingDelegationEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "creation_height",
                |m: &UnbondingDelegationEntry| { &m.creation_height },
                |m: &mut UnbondingDelegationEntry| { &mut m.creation_height },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "completion_time",
                |m: &UnbondingDelegationEntry| { &m.completion_time },
                |m: &mut UnbondingDelegationEntry| { &mut m.completion_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "initial_balance",
                |m: &UnbondingDelegationEntry| { &m.initial_balance },
                |m: &mut UnbondingDelegationEntry| { &mut m.initial_balance },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "balance",
                |m: &UnbondingDelegationEntry| { &m.balance },
                |m: &mut UnbondingDelegationEntry| { &mut m.balance },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UnbondingDelegationEntry>(
                "UnbondingDelegationEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UnbondingDelegationEntry {
        static instance: ::protobuf::rt::LazyV2<UnbondingDelegationEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UnbondingDelegationEntry::new)
    }
}

impl ::protobuf::Clear for UnbondingDelegationEntry {
    fn clear(&mut self) {
        self.creation_height = 0;
        self.completion_time.clear();
        self.initial_balance.clear();
        self.balance.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnbondingDelegationEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnbondingDelegationEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RedelegationEntry {
    // message fields
    pub creation_height: i64,
    pub completion_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub initial_balance: ::std::string::String,
    pub shares_dst: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RedelegationEntry {
    fn default() -> &'a RedelegationEntry {
        <RedelegationEntry as ::protobuf::Message>::default_instance()
    }
}

impl RedelegationEntry {
    pub fn new() -> RedelegationEntry {
        ::std::default::Default::default()
    }

    // int64 creation_height = 1;


    pub fn get_creation_height(&self) -> i64 {
        self.creation_height
    }
    pub fn clear_creation_height(&mut self) {
        self.creation_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_creation_height(&mut self, v: i64) {
        self.creation_height = v;
    }

    // .google.protobuf.Timestamp completion_time = 2;


    pub fn get_completion_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.completion_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_completion_time(&mut self) {
        self.completion_time.clear();
    }

    pub fn has_completion_time(&self) -> bool {
        self.completion_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_completion_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.completion_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_completion_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.completion_time.is_none() {
            self.completion_time.set_default();
        }
        self.completion_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_completion_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.completion_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // string initial_balance = 3;


    pub fn get_initial_balance(&self) -> &str {
        &self.initial_balance
    }
    pub fn clear_initial_balance(&mut self) {
        self.initial_balance.clear();
    }

    // Param is passed by value, moved
    pub fn set_initial_balance(&mut self, v: ::std::string::String) {
        self.initial_balance = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_initial_balance(&mut self) -> &mut ::std::string::String {
        &mut self.initial_balance
    }

    // Take field
    pub fn take_initial_balance(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.initial_balance, ::std::string::String::new())
    }

    // string shares_dst = 4;


    pub fn get_shares_dst(&self) -> &str {
        &self.shares_dst
    }
    pub fn clear_shares_dst(&mut self) {
        self.shares_dst.clear();
    }

    // Param is passed by value, moved
    pub fn set_shares_dst(&mut self, v: ::std::string::String) {
        self.shares_dst = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shares_dst(&mut self) -> &mut ::std::string::String {
        &mut self.shares_dst
    }

    // Take field
    pub fn take_shares_dst(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.shares_dst, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RedelegationEntry {
    fn is_initialized(&self) -> bool {
        for v in &self.completion_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.creation_height = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.completion_time)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.initial_balance)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.shares_dst)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.creation_height != 0 {
            my_size += ::protobuf::rt::value_size(1, self.creation_height, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.completion_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.initial_balance.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.initial_balance);
        }
        if !self.shares_dst.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.shares_dst);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.creation_height != 0 {
            os.write_int64(1, self.creation_height)?;
        }
        if let Some(ref v) = self.completion_time.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.initial_balance.is_empty() {
            os.write_string(3, &self.initial_balance)?;
        }
        if !self.shares_dst.is_empty() {
            os.write_string(4, &self.shares_dst)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RedelegationEntry {
        RedelegationEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "creation_height",
                |m: &RedelegationEntry| { &m.creation_height },
                |m: &mut RedelegationEntry| { &mut m.creation_height },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "completion_time",
                |m: &RedelegationEntry| { &m.completion_time },
                |m: &mut RedelegationEntry| { &mut m.completion_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "initial_balance",
                |m: &RedelegationEntry| { &m.initial_balance },
                |m: &mut RedelegationEntry| { &mut m.initial_balance },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "shares_dst",
                |m: &RedelegationEntry| { &m.shares_dst },
                |m: &mut RedelegationEntry| { &mut m.shares_dst },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RedelegationEntry>(
                "RedelegationEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RedelegationEntry {
        static instance: ::protobuf::rt::LazyV2<RedelegationEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RedelegationEntry::new)
    }
}

impl ::protobuf::Clear for RedelegationEntry {
    fn clear(&mut self) {
        self.creation_height = 0;
        self.completion_time.clear();
        self.initial_balance.clear();
        self.shares_dst.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RedelegationEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RedelegationEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Redelegation {
    // message fields
    pub delegator_address: ::std::string::String,
    pub validator_src_address: ::std::string::String,
    pub validator_dst_address: ::std::string::String,
    pub entries: ::protobuf::RepeatedField<RedelegationEntry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Redelegation {
    fn default() -> &'a Redelegation {
        <Redelegation as ::protobuf::Message>::default_instance()
    }
}

impl Redelegation {
    pub fn new() -> Redelegation {
        ::std::default::Default::default()
    }

    // string delegator_address = 1;


    pub fn get_delegator_address(&self) -> &str {
        &self.delegator_address
    }
    pub fn clear_delegator_address(&mut self) {
        self.delegator_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_delegator_address(&mut self, v: ::std::string::String) {
        self.delegator_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_delegator_address(&mut self) -> &mut ::std::string::String {
        &mut self.delegator_address
    }

    // Take field
    pub fn take_delegator_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.delegator_address, ::std::string::String::new())
    }

    // string validator_src_address = 2;


    pub fn get_validator_src_address(&self) -> &str {
        &self.validator_src_address
    }
    pub fn clear_validator_src_address(&mut self) {
        self.validator_src_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_validator_src_address(&mut self, v: ::std::string::String) {
        self.validator_src_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_validator_src_address(&mut self) -> &mut ::std::string::String {
        &mut self.validator_src_address
    }

    // Take field
    pub fn take_validator_src_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.validator_src_address, ::std::string::String::new())
    }

    // string validator_dst_address = 3;


    pub fn get_validator_dst_address(&self) -> &str {
        &self.validator_dst_address
    }
    pub fn clear_validator_dst_address(&mut self) {
        self.validator_dst_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_validator_dst_address(&mut self, v: ::std::string::String) {
        self.validator_dst_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_validator_dst_address(&mut self) -> &mut ::std::string::String {
        &mut self.validator_dst_address
    }

    // Take field
    pub fn take_validator_dst_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.validator_dst_address, ::std::string::String::new())
    }

    // repeated .cosmos.staking.v1beta1.RedelegationEntry entries = 4;


    pub fn get_entries(&self) -> &[RedelegationEntry] {
        &self.entries
    }
    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::protobuf::RepeatedField<RedelegationEntry>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::protobuf::RepeatedField<RedelegationEntry> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::protobuf::RepeatedField<RedelegationEntry> {
        ::std::mem::replace(&mut self.entries, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Redelegation {
    fn is_initialized(&self) -> bool {
        for v in &self.entries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.delegator_address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.validator_src_address)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.validator_dst_address)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entries)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.delegator_address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.delegator_address);
        }
        if !self.validator_src_address.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.validator_src_address);
        }
        if !self.validator_dst_address.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.validator_dst_address);
        }
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.delegator_address.is_empty() {
            os.write_string(1, &self.delegator_address)?;
        }
        if !self.validator_src_address.is_empty() {
            os.write_string(2, &self.validator_src_address)?;
        }
        if !self.validator_dst_address.is_empty() {
            os.write_string(3, &self.validator_dst_address)?;
        }
        for v in &self.entries {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Redelegation {
        Redelegation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "delegator_address",
                |m: &Redelegation| { &m.delegator_address },
                |m: &mut Redelegation| { &mut m.delegator_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "validator_src_address",
                |m: &Redelegation| { &m.validator_src_address },
                |m: &mut Redelegation| { &mut m.validator_src_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "validator_dst_address",
                |m: &Redelegation| { &m.validator_dst_address },
                |m: &mut Redelegation| { &mut m.validator_dst_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RedelegationEntry>>(
                "entries",
                |m: &Redelegation| { &m.entries },
                |m: &mut Redelegation| { &mut m.entries },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Redelegation>(
                "Redelegation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Redelegation {
        static instance: ::protobuf::rt::LazyV2<Redelegation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Redelegation::new)
    }
}

impl ::protobuf::Clear for Redelegation {
    fn clear(&mut self) {
        self.delegator_address.clear();
        self.validator_src_address.clear();
        self.validator_dst_address.clear();
        self.entries.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Redelegation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Redelegation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Params {
    // message fields
    pub unbonding_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub max_validators: u32,
    pub max_entries: u32,
    pub historical_entries: u32,
    pub bond_denom: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Params {
    fn default() -> &'a Params {
        <Params as ::protobuf::Message>::default_instance()
    }
}

impl Params {
    pub fn new() -> Params {
        ::std::default::Default::default()
    }

    // .google.protobuf.Duration unbonding_time = 1;


    pub fn get_unbonding_time(&self) -> &::protobuf::well_known_types::Duration {
        self.unbonding_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_unbonding_time(&mut self) {
        self.unbonding_time.clear();
    }

    pub fn has_unbonding_time(&self) -> bool {
        self.unbonding_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unbonding_time(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.unbonding_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unbonding_time(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.unbonding_time.is_none() {
            self.unbonding_time.set_default();
        }
        self.unbonding_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_unbonding_time(&mut self) -> ::protobuf::well_known_types::Duration {
        self.unbonding_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // uint32 max_validators = 2;


    pub fn get_max_validators(&self) -> u32 {
        self.max_validators
    }
    pub fn clear_max_validators(&mut self) {
        self.max_validators = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_validators(&mut self, v: u32) {
        self.max_validators = v;
    }

    // uint32 max_entries = 3;


    pub fn get_max_entries(&self) -> u32 {
        self.max_entries
    }
    pub fn clear_max_entries(&mut self) {
        self.max_entries = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_entries(&mut self, v: u32) {
        self.max_entries = v;
    }

    // uint32 historical_entries = 4;


    pub fn get_historical_entries(&self) -> u32 {
        self.historical_entries
    }
    pub fn clear_historical_entries(&mut self) {
        self.historical_entries = 0;
    }

    // Param is passed by value, moved
    pub fn set_historical_entries(&mut self, v: u32) {
        self.historical_entries = v;
    }

    // string bond_denom = 5;


    pub fn get_bond_denom(&self) -> &str {
        &self.bond_denom
    }
    pub fn clear_bond_denom(&mut self) {
        self.bond_denom.clear();
    }

    // Param is passed by value, moved
    pub fn set_bond_denom(&mut self, v: ::std::string::String) {
        self.bond_denom = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bond_denom(&mut self) -> &mut ::std::string::String {
        &mut self.bond_denom
    }

    // Take field
    pub fn take_bond_denom(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bond_denom, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Params {
    fn is_initialized(&self) -> bool {
        for v in &self.unbonding_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unbonding_time)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_validators = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_entries = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.historical_entries = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bond_denom)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.unbonding_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.max_validators != 0 {
            my_size += ::protobuf::rt::value_size(2, self.max_validators, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_entries != 0 {
            my_size += ::protobuf::rt::value_size(3, self.max_entries, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.historical_entries != 0 {
            my_size += ::protobuf::rt::value_size(4, self.historical_entries, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.bond_denom.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.bond_denom);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.unbonding_time.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.max_validators != 0 {
            os.write_uint32(2, self.max_validators)?;
        }
        if self.max_entries != 0 {
            os.write_uint32(3, self.max_entries)?;
        }
        if self.historical_entries != 0 {
            os.write_uint32(4, self.historical_entries)?;
        }
        if !self.bond_denom.is_empty() {
            os.write_string(5, &self.bond_denom)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Params {
        Params::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "unbonding_time",
                |m: &Params| { &m.unbonding_time },
                |m: &mut Params| { &mut m.unbonding_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "max_validators",
                |m: &Params| { &m.max_validators },
                |m: &mut Params| { &mut m.max_validators },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "max_entries",
                |m: &Params| { &m.max_entries },
                |m: &mut Params| { &mut m.max_entries },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "historical_entries",
                |m: &Params| { &m.historical_entries },
                |m: &mut Params| { &mut m.historical_entries },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bond_denom",
                |m: &Params| { &m.bond_denom },
                |m: &mut Params| { &mut m.bond_denom },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Params>(
                "Params",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Params {
        static instance: ::protobuf::rt::LazyV2<Params> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Params::new)
    }
}

impl ::protobuf::Clear for Params {
    fn clear(&mut self) {
        self.unbonding_time.clear();
        self.max_validators = 0;
        self.max_entries = 0;
        self.historical_entries = 0;
        self.bond_denom.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Params {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Params {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DelegationResponse {
    // message fields
    pub delegation: ::protobuf::SingularPtrField<Delegation>,
    pub balance: ::protobuf::SingularPtrField<super::coin::Coin>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DelegationResponse {
    fn default() -> &'a DelegationResponse {
        <DelegationResponse as ::protobuf::Message>::default_instance()
    }
}

impl DelegationResponse {
    pub fn new() -> DelegationResponse {
        ::std::default::Default::default()
    }

    // .cosmos.staking.v1beta1.Delegation delegation = 1;


    pub fn get_delegation(&self) -> &Delegation {
        self.delegation.as_ref().unwrap_or_else(|| <Delegation as ::protobuf::Message>::default_instance())
    }
    pub fn clear_delegation(&mut self) {
        self.delegation.clear();
    }

    pub fn has_delegation(&self) -> bool {
        self.delegation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delegation(&mut self, v: Delegation) {
        self.delegation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_delegation(&mut self) -> &mut Delegation {
        if self.delegation.is_none() {
            self.delegation.set_default();
        }
        self.delegation.as_mut().unwrap()
    }

    // Take field
    pub fn take_delegation(&mut self) -> Delegation {
        self.delegation.take().unwrap_or_else(|| Delegation::new())
    }

    // .cosmos.base.v1beta1.Coin balance = 2;


    pub fn get_balance(&self) -> &super::coin::Coin {
        self.balance.as_ref().unwrap_or_else(|| <super::coin::Coin as ::protobuf::Message>::default_instance())
    }
    pub fn clear_balance(&mut self) {
        self.balance.clear();
    }

    pub fn has_balance(&self) -> bool {
        self.balance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance(&mut self, v: super::coin::Coin) {
        self.balance = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_balance(&mut self) -> &mut super::coin::Coin {
        if self.balance.is_none() {
            self.balance.set_default();
        }
        self.balance.as_mut().unwrap()
    }

    // Take field
    pub fn take_balance(&mut self) -> super::coin::Coin {
        self.balance.take().unwrap_or_else(|| super::coin::Coin::new())
    }
}

impl ::protobuf::Message for DelegationResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.delegation {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.balance {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.delegation)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.balance)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.delegation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.balance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.delegation.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.balance.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DelegationResponse {
        DelegationResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Delegation>>(
                "delegation",
                |m: &DelegationResponse| { &m.delegation },
                |m: &mut DelegationResponse| { &mut m.delegation },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::coin::Coin>>(
                "balance",
                |m: &DelegationResponse| { &m.balance },
                |m: &mut DelegationResponse| { &mut m.balance },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DelegationResponse>(
                "DelegationResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DelegationResponse {
        static instance: ::protobuf::rt::LazyV2<DelegationResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DelegationResponse::new)
    }
}

impl ::protobuf::Clear for DelegationResponse {
    fn clear(&mut self) {
        self.delegation.clear();
        self.balance.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DelegationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DelegationResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RedelegationEntryResponse {
    // message fields
    pub redelegation_entry: ::protobuf::SingularPtrField<RedelegationEntry>,
    pub balance: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RedelegationEntryResponse {
    fn default() -> &'a RedelegationEntryResponse {
        <RedelegationEntryResponse as ::protobuf::Message>::default_instance()
    }
}

impl RedelegationEntryResponse {
    pub fn new() -> RedelegationEntryResponse {
        ::std::default::Default::default()
    }

    // .cosmos.staking.v1beta1.RedelegationEntry redelegation_entry = 1;


    pub fn get_redelegation_entry(&self) -> &RedelegationEntry {
        self.redelegation_entry.as_ref().unwrap_or_else(|| <RedelegationEntry as ::protobuf::Message>::default_instance())
    }
    pub fn clear_redelegation_entry(&mut self) {
        self.redelegation_entry.clear();
    }

    pub fn has_redelegation_entry(&self) -> bool {
        self.redelegation_entry.is_some()
    }

    // Param is passed by value, moved
    pub fn set_redelegation_entry(&mut self, v: RedelegationEntry) {
        self.redelegation_entry = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_redelegation_entry(&mut self) -> &mut RedelegationEntry {
        if self.redelegation_entry.is_none() {
            self.redelegation_entry.set_default();
        }
        self.redelegation_entry.as_mut().unwrap()
    }

    // Take field
    pub fn take_redelegation_entry(&mut self) -> RedelegationEntry {
        self.redelegation_entry.take().unwrap_or_else(|| RedelegationEntry::new())
    }

    // string balance = 4;


    pub fn get_balance(&self) -> &str {
        &self.balance
    }
    pub fn clear_balance(&mut self) {
        self.balance.clear();
    }

    // Param is passed by value, moved
    pub fn set_balance(&mut self, v: ::std::string::String) {
        self.balance = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_balance(&mut self) -> &mut ::std::string::String {
        &mut self.balance
    }

    // Take field
    pub fn take_balance(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.balance, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RedelegationEntryResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.redelegation_entry {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.redelegation_entry)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.balance)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.redelegation_entry.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.balance.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.balance);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.redelegation_entry.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.balance.is_empty() {
            os.write_string(4, &self.balance)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RedelegationEntryResponse {
        RedelegationEntryResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RedelegationEntry>>(
                "redelegation_entry",
                |m: &RedelegationEntryResponse| { &m.redelegation_entry },
                |m: &mut RedelegationEntryResponse| { &mut m.redelegation_entry },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "balance",
                |m: &RedelegationEntryResponse| { &m.balance },
                |m: &mut RedelegationEntryResponse| { &mut m.balance },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RedelegationEntryResponse>(
                "RedelegationEntryResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RedelegationEntryResponse {
        static instance: ::protobuf::rt::LazyV2<RedelegationEntryResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RedelegationEntryResponse::new)
    }
}

impl ::protobuf::Clear for RedelegationEntryResponse {
    fn clear(&mut self) {
        self.redelegation_entry.clear();
        self.balance.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RedelegationEntryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RedelegationEntryResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RedelegationResponse {
    // message fields
    pub redelegation: ::protobuf::SingularPtrField<Redelegation>,
    pub entries: ::protobuf::RepeatedField<RedelegationEntryResponse>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RedelegationResponse {
    fn default() -> &'a RedelegationResponse {
        <RedelegationResponse as ::protobuf::Message>::default_instance()
    }
}

impl RedelegationResponse {
    pub fn new() -> RedelegationResponse {
        ::std::default::Default::default()
    }

    // .cosmos.staking.v1beta1.Redelegation redelegation = 1;


    pub fn get_redelegation(&self) -> &Redelegation {
        self.redelegation.as_ref().unwrap_or_else(|| <Redelegation as ::protobuf::Message>::default_instance())
    }
    pub fn clear_redelegation(&mut self) {
        self.redelegation.clear();
    }

    pub fn has_redelegation(&self) -> bool {
        self.redelegation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_redelegation(&mut self, v: Redelegation) {
        self.redelegation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_redelegation(&mut self) -> &mut Redelegation {
        if self.redelegation.is_none() {
            self.redelegation.set_default();
        }
        self.redelegation.as_mut().unwrap()
    }

    // Take field
    pub fn take_redelegation(&mut self) -> Redelegation {
        self.redelegation.take().unwrap_or_else(|| Redelegation::new())
    }

    // repeated .cosmos.staking.v1beta1.RedelegationEntryResponse entries = 2;


    pub fn get_entries(&self) -> &[RedelegationEntryResponse] {
        &self.entries
    }
    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::protobuf::RepeatedField<RedelegationEntryResponse>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::protobuf::RepeatedField<RedelegationEntryResponse> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::protobuf::RepeatedField<RedelegationEntryResponse> {
        ::std::mem::replace(&mut self.entries, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RedelegationResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.redelegation {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.entries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.redelegation)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entries)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.redelegation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.redelegation.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.entries {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RedelegationResponse {
        RedelegationResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Redelegation>>(
                "redelegation",
                |m: &RedelegationResponse| { &m.redelegation },
                |m: &mut RedelegationResponse| { &mut m.redelegation },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RedelegationEntryResponse>>(
                "entries",
                |m: &RedelegationResponse| { &m.entries },
                |m: &mut RedelegationResponse| { &mut m.entries },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RedelegationResponse>(
                "RedelegationResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RedelegationResponse {
        static instance: ::protobuf::rt::LazyV2<RedelegationResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RedelegationResponse::new)
    }
}

impl ::protobuf::Clear for RedelegationResponse {
    fn clear(&mut self) {
        self.redelegation.clear();
        self.entries.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RedelegationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RedelegationResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Pool {
    // message fields
    pub not_bonded_tokens: ::std::string::String,
    pub bonded_tokens: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Pool {
    fn default() -> &'a Pool {
        <Pool as ::protobuf::Message>::default_instance()
    }
}

impl Pool {
    pub fn new() -> Pool {
        ::std::default::Default::default()
    }

    // string not_bonded_tokens = 1;


    pub fn get_not_bonded_tokens(&self) -> &str {
        &self.not_bonded_tokens
    }
    pub fn clear_not_bonded_tokens(&mut self) {
        self.not_bonded_tokens.clear();
    }

    // Param is passed by value, moved
    pub fn set_not_bonded_tokens(&mut self, v: ::std::string::String) {
        self.not_bonded_tokens = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_not_bonded_tokens(&mut self) -> &mut ::std::string::String {
        &mut self.not_bonded_tokens
    }

    // Take field
    pub fn take_not_bonded_tokens(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.not_bonded_tokens, ::std::string::String::new())
    }

    // string bonded_tokens = 2;


    pub fn get_bonded_tokens(&self) -> &str {
        &self.bonded_tokens
    }
    pub fn clear_bonded_tokens(&mut self) {
        self.bonded_tokens.clear();
    }

    // Param is passed by value, moved
    pub fn set_bonded_tokens(&mut self, v: ::std::string::String) {
        self.bonded_tokens = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bonded_tokens(&mut self) -> &mut ::std::string::String {
        &mut self.bonded_tokens
    }

    // Take field
    pub fn take_bonded_tokens(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bonded_tokens, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Pool {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.not_bonded_tokens)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bonded_tokens)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.not_bonded_tokens.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.not_bonded_tokens);
        }
        if !self.bonded_tokens.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.bonded_tokens);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.not_bonded_tokens.is_empty() {
            os.write_string(1, &self.not_bonded_tokens)?;
        }
        if !self.bonded_tokens.is_empty() {
            os.write_string(2, &self.bonded_tokens)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Pool {
        Pool::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "not_bonded_tokens",
                |m: &Pool| { &m.not_bonded_tokens },
                |m: &mut Pool| { &mut m.not_bonded_tokens },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bonded_tokens",
                |m: &Pool| { &m.bonded_tokens },
                |m: &mut Pool| { &mut m.bonded_tokens },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Pool>(
                "Pool",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Pool {
        static instance: ::protobuf::rt::LazyV2<Pool> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Pool::new)
    }
}

impl ::protobuf::Clear for Pool {
    fn clear(&mut self) {
        self.not_bonded_tokens.clear();
        self.bonded_tokens.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Pool {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pool {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum BondStatus {
    BOND_STATUS_UNSPECIFIED = 0,
    BOND_STATUS_UNBONDED = 1,
    BOND_STATUS_UNBONDING = 2,
    BOND_STATUS_BONDED = 3,
}

impl ::protobuf::ProtobufEnum for BondStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BondStatus> {
        match value {
            0 => ::std::option::Option::Some(BondStatus::BOND_STATUS_UNSPECIFIED),
            1 => ::std::option::Option::Some(BondStatus::BOND_STATUS_UNBONDED),
            2 => ::std::option::Option::Some(BondStatus::BOND_STATUS_UNBONDING),
            3 => ::std::option::Option::Some(BondStatus::BOND_STATUS_BONDED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [BondStatus] = &[
            BondStatus::BOND_STATUS_UNSPECIFIED,
            BondStatus::BOND_STATUS_UNBONDED,
            BondStatus::BOND_STATUS_UNBONDING,
            BondStatus::BOND_STATUS_BONDED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<BondStatus>("BondStatus", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for BondStatus {
}

impl ::std::default::Default for BondStatus {
    fn default() -> Self {
        BondStatus::BOND_STATUS_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for BondStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n$cosmos/staking/v1beta1/staking.proto\x12\x16cosmos.staking.v1beta1\
    \x1a\x14gogoproto/gogo.proto\x1a\x19google/protobuf/any.proto\x1a\x1egoo\
    gle/protobuf/duration.proto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\
    \x19cosmos_proto/cosmos.proto\x1a\x1ecosmos/base/v1beta1/coin.proto\x1a\
    \x1ctendermint/types/types.proto\"\x89\x01\n\x0eHistoricalInfo\x126\n\
    \x06header\x18\x01\x20\x01(\x0b2\x18.tendermint.types.HeaderR\x06headerB\
    \x04\xc8\xde\x1f\0\x12?\n\x06valset\x18\x02\x20\x03(\x0b2!.cosmos.stakin\
    g.v1beta1.ValidatorR\x06valsetB\x04\xc8\xde\x1f\0\"\xaf\x02\n\x0fCommiss\
    ionRates\x12B\n\x04rate\x18\x01\x20\x01(\tR\x04rateB.\xda\xde\x1f&github\
    .com/cosmos/cosmos-sdk/types.Dec\xc8\xde\x1f\0\x12\\\n\x08max_rate\x18\
    \x02\x20\x01(\tR\x07maxRateBA\xc8\xde\x1f\0\xda\xde\x1f&github.com/cosmo\
    s/cosmos-sdk/types.Dec\xf2\xde\x1f\x0fyaml:\"max_rate\"\x12p\n\x0fmax_ch\
    ange_rate\x18\x03\x20\x01(\tR\rmaxChangeRateBH\xda\xde\x1f&github.com/co\
    smos/cosmos-sdk/types.Dec\xc8\xde\x1f\0\xf2\xde\x1f\x16yaml:\"max_change\
    _rate\":\x08\xe8\xa0\x1f\x01\x98\xa0\x1f\0\"\xd1\x01\n\nCommission\x12\\\
    \n\x10commission_rates\x18\x01\x20\x01(\x0b2'.cosmos.staking.v1beta1.Com\
    missionRatesR\x0fcommissionRatesB\x08\xc8\xde\x1f\0\xd0\xde\x1f\x01\x12[\
    \n\x0bupdate_time\x18\x02\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\n\
    updateTimeB\x1e\xc8\xde\x1f\0\xf2\xde\x1f\x12yaml:\"update_time\"\x90\
    \xdf\x1f\x01:\x08\xe8\xa0\x1f\x01\x98\xa0\x1f\0\"\xc9\x01\n\x0bDescripti\
    on\x12\x18\n\x07moniker\x18\x01\x20\x01(\tR\x07moniker\x12\x1a\n\x08iden\
    tity\x18\x02\x20\x01(\tR\x08identity\x12\x18\n\x07website\x18\x03\x20\
    \x01(\tR\x07website\x12F\n\x10security_contact\x18\x04\x20\x01(\tR\x0fse\
    curityContactB\x1b\xf2\xde\x1f\x17yaml:\"security_contact\"\x12\x18\n\
    \x07details\x18\x05\x20\x01(\tR\x07details:\x08\xe8\xa0\x1f\x01\x98\xa0\
    \x1f\0\"\xac\x07\n\tValidator\x12F\n\x10operator_address\x18\x01\x20\x01\
    (\tR\x0foperatorAddressB\x1b\xf2\xde\x1f\x17yaml:\"operator_address\"\
    \x12t\n\x10consensus_pubkey\x18\x02\x20\x01(\x0b2\x14.google.protobuf.An\
    yR\x0fconsensusPubkeyB3\xca\xb4-\x14cosmos.crypto.PubKey\xf2\xde\x1f\x17\
    yaml:\"consensus_pubkey\"\x12\x16\n\x06jailed\x18\x03\x20\x01(\x08R\x06j\
    ailed\x12:\n\x06status\x18\x04\x20\x01(\x0e2\".cosmos.staking.v1beta1.Bo\
    ndStatusR\x06status\x12F\n\x06tokens\x18\x05\x20\x01(\tR\x06tokensB.\xc8\
    \xde\x1f\0\xda\xde\x1f&github.com/cosmos/cosmos-sdk/types.Int\x12t\n\x10\
    delegator_shares\x18\x06\x20\x01(\tR\x0fdelegatorSharesBI\xc8\xde\x1f\0\
    \xf2\xde\x1f\x17yaml:\"delegator_shares\"\xda\xde\x1f&github.com/cosmos/\
    cosmos-sdk/types.Dec\x12K\n\x0bdescription\x18\x07\x20\x01(\x0b2#.cosmos\
    .staking.v1beta1.DescriptionR\x0bdescriptionB\x04\xc8\xde\x1f\0\x12F\n\
    \x10unbonding_height\x18\x08\x20\x01(\x03R\x0funbondingHeightB\x1b\xf2\
    \xde\x1f\x17yaml:\"unbonding_height\"\x12d\n\x0eunbonding_time\x18\t\x20\
    \x01(\x0b2\x1a.google.protobuf.TimestampR\runbondingTimeB!\xc8\xde\x1f\0\
    \x90\xdf\x1f\x01\xf2\xde\x1f\x15yaml:\"unbonding_time\"\x12H\n\ncommissi\
    on\x18\n\x20\x01(\x0b2\".cosmos.staking.v1beta1.CommissionR\ncommissionB\
    \x04\xc8\xde\x1f\0\x12|\n\x13min_self_delegation\x18\x0b\x20\x01(\tR\x11\
    minSelfDelegationBL\xf2\xde\x1f\x1ayaml:\"min_self_delegation\"\xda\xde\
    \x1f&github.com/cosmos/cosmos-sdk/types.Int\xc8\xde\x1f\0:\x0c\x88\xa0\
    \x1f\0\x98\xa0\x1f\0\xe8\xa0\x1f\0\"6\n\x0cValAddresses\x12\x1c\n\taddre\
    sses\x18\x01\x20\x03(\tR\taddresses:\x08\x98\xa0\x1f\0\x80\xdc\x20\x01\"\
    \xac\x01\n\x06DVPair\x12I\n\x11delegator_address\x18\x01\x20\x01(\tR\x10\
    delegatorAddressB\x1c\xf2\xde\x1f\x18yaml:\"delegator_address\"\x12I\n\
    \x11validator_address\x18\x02\x20\x01(\tR\x10validatorAddressB\x1c\xf2\
    \xde\x1f\x18yaml:\"validator_address\":\x0c\x98\xa0\x1f\0\xe8\xa0\x1f\0\
    \x88\xa0\x1f\0\"E\n\x07DVPairs\x12:\n\x05pairs\x18\x01\x20\x03(\x0b2\x1e\
    .cosmos.staking.v1beta1.DVPairR\x05pairsB\x04\xc8\xde\x1f\0\"\x91\x02\n\
    \nDVVTriplet\x12I\n\x11delegator_address\x18\x01\x20\x01(\tR\x10delegato\
    rAddressB\x1c\xf2\xde\x1f\x18yaml:\"delegator_address\"\x12T\n\x15valida\
    tor_src_address\x18\x02\x20\x01(\tR\x13validatorSrcAddressB\x20\xf2\xde\
    \x1f\x1cyaml:\"validator_src_address\"\x12T\n\x15validator_dst_address\
    \x18\x03\x20\x01(\tR\x13validatorDstAddressB\x20\xf2\xde\x1f\x1cyaml:\"v\
    alidator_dst_address\":\x0c\xe8\xa0\x1f\0\x88\xa0\x1f\0\x98\xa0\x1f\0\"S\
    \n\x0bDVVTriplets\x12D\n\x08triplets\x18\x01\x20\x03(\x0b2\".cosmos.stak\
    ing.v1beta1.DVVTripletR\x08tripletsB\x04\xc8\xde\x1f\0\"\xf8\x01\n\nDele\
    gation\x12I\n\x11delegator_address\x18\x01\x20\x01(\tR\x10delegatorAddre\
    ssB\x1c\xf2\xde\x1f\x18yaml:\"delegator_address\"\x12I\n\x11validator_ad\
    dress\x18\x02\x20\x01(\tR\x10validatorAddressB\x1c\xf2\xde\x1f\x18yaml:\
    \"validator_address\"\x12F\n\x06shares\x18\x03\x20\x01(\tR\x06sharesB.\
    \xda\xde\x1f&github.com/cosmos/cosmos-sdk/types.Dec\xc8\xde\x1f\0:\x0c\
    \x88\xa0\x1f\0\x98\xa0\x1f\0\xe8\xa0\x1f\0\"\x8b\x02\n\x13UnbondingDeleg\
    ation\x12I\n\x11delegator_address\x18\x01\x20\x01(\tR\x10delegatorAddres\
    sB\x1c\xf2\xde\x1f\x18yaml:\"delegator_address\"\x12I\n\x11validator_add\
    ress\x18\x02\x20\x01(\tR\x10validatorAddressB\x1c\xf2\xde\x1f\x18yaml:\"\
    validator_address\"\x12P\n\x07entries\x18\x03\x20\x03(\x0b20.cosmos.stak\
    ing.v1beta1.UnbondingDelegationEntryR\x07entriesB\x04\xc8\xde\x1f\0:\x0c\
    \x88\xa0\x1f\0\xe8\xa0\x1f\0\x98\xa0\x1f\0\"\x8f\x03\n\x18UnbondingDeleg\
    ationEntry\x12C\n\x0fcreation_height\x18\x01\x20\x01(\x03R\x0ecreationHe\
    ightB\x1a\xf2\xde\x1f\x16yaml:\"creation_height\"\x12g\n\x0fcompletion_t\
    ime\x18\x02\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x0ecompletionTi\
    meB\"\xf2\xde\x1f\x16yaml:\"completion_time\"\x90\xdf\x1f\x01\xc8\xde\
    \x1f\0\x12q\n\x0finitial_balance\x18\x03\x20\x01(\tR\x0einitialBalanceBH\
    \xf2\xde\x1f\x16yaml:\"initial_balance\"\xc8\xde\x1f\0\xda\xde\x1f&githu\
    b.com/cosmos/cosmos-sdk/types.Int\x12H\n\x07balance\x18\x04\x20\x01(\tR\
    \x07balanceB.\xc8\xde\x1f\0\xda\xde\x1f&github.com/cosmos/cosmos-sdk/typ\
    es.Int:\x08\x98\xa0\x1f\0\xe8\xa0\x1f\x01\"\x8d\x03\n\x11RedelegationEnt\
    ry\x12C\n\x0fcreation_height\x18\x01\x20\x01(\x03R\x0ecreationHeightB\
    \x1a\xf2\xde\x1f\x16yaml:\"creation_height\"\x12g\n\x0fcompletion_time\
    \x18\x02\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x0ecompletionTimeB\
    \"\x90\xdf\x1f\x01\xc8\xde\x1f\0\xf2\xde\x1f\x16yaml:\"completion_time\"\
    \x12q\n\x0finitial_balance\x18\x03\x20\x01(\tR\x0einitialBalanceBH\xf2\
    \xde\x1f\x16yaml:\"initial_balance\"\xc8\xde\x1f\0\xda\xde\x1f&github.co\
    m/cosmos/cosmos-sdk/types.Int\x12M\n\nshares_dst\x18\x04\x20\x01(\tR\tsh\
    aresDstB.\xda\xde\x1f&github.com/cosmos/cosmos-sdk/types.Dec\xc8\xde\x1f\
    \0:\x08\x98\xa0\x1f\0\xe8\xa0\x1f\x01\"\xde\x02\n\x0cRedelegation\x12I\n\
    \x11delegator_address\x18\x01\x20\x01(\tR\x10delegatorAddressB\x1c\xf2\
    \xde\x1f\x18yaml:\"delegator_address\"\x12T\n\x15validator_src_address\
    \x18\x02\x20\x01(\tR\x13validatorSrcAddressB\x20\xf2\xde\x1f\x1cyaml:\"v\
    alidator_src_address\"\x12T\n\x15validator_dst_address\x18\x03\x20\x01(\
    \tR\x13validatorDstAddressB\x20\xf2\xde\x1f\x1cyaml:\"validator_dst_addr\
    ess\"\x12I\n\x07entries\x18\x04\x20\x03(\x0b2).cosmos.staking.v1beta1.Re\
    delegationEntryR\x07entriesB\x04\xc8\xde\x1f\0:\x0c\xe8\xa0\x1f\0\x88\
    \xa0\x1f\0\x98\xa0\x1f\0\"\xf6\x02\n\x06Params\x12c\n\x0eunbonding_time\
    \x18\x01\x20\x01(\x0b2\x19.google.protobuf.DurationR\runbondingTimeB!\
    \xf2\xde\x1f\x15yaml:\"unbonding_time\"\xc8\xde\x1f\0\x98\xdf\x1f\x01\
    \x12@\n\x0emax_validators\x18\x02\x20\x01(\rR\rmaxValidatorsB\x19\xf2\
    \xde\x1f\x15yaml:\"max_validators\"\x127\n\x0bmax_entries\x18\x03\x20\
    \x01(\rR\nmaxEntriesB\x16\xf2\xde\x1f\x12yaml:\"max_entries\"\x12L\n\x12\
    historical_entries\x18\x04\x20\x01(\rR\x11historicalEntriesB\x1d\xf2\xde\
    \x1f\x19yaml:\"historical_entries\"\x124\n\nbond_denom\x18\x05\x20\x01(\
    \tR\tbondDenomB\x15\xf2\xde\x1f\x11yaml:\"bond_denom\":\x08\x98\xa0\x1f\
    \0\xe8\xa0\x1f\x01\"\xa3\x01\n\x12DelegationResponse\x12H\n\ndelegation\
    \x18\x01\x20\x01(\x0b2\".cosmos.staking.v1beta1.DelegationR\ndelegationB\
    \x04\xc8\xde\x1f\0\x129\n\x07balance\x18\x02\x20\x01(\x0b2\x19.cosmos.ba\
    se.v1beta1.CoinR\x07balanceB\x04\xc8\xde\x1f\0:\x08\x98\xa0\x1f\0\xe8\
    \xa0\x1f\0\"\xcb\x01\n\x19RedelegationEntryResponse\x12^\n\x12redelegati\
    on_entry\x18\x01\x20\x01(\x0b2).cosmos.staking.v1beta1.RedelegationEntry\
    R\x11redelegationEntryB\x04\xc8\xde\x1f\0\x12H\n\x07balance\x18\x04\x20\
    \x01(\tR\x07balanceB.\xda\xde\x1f&github.com/cosmos/cosmos-sdk/types.Int\
    \xc8\xde\x1f\0:\x04\xe8\xa0\x1f\x01\"\xbf\x01\n\x14RedelegationResponse\
    \x12N\n\x0credelegation\x18\x01\x20\x01(\x0b2$.cosmos.staking.v1beta1.Re\
    delegationR\x0credelegationB\x04\xc8\xde\x1f\0\x12Q\n\x07entries\x18\x02\
    \x20\x03(\x0b21.cosmos.staking.v1beta1.RedelegationEntryResponseR\x07ent\
    riesB\x04\xc8\xde\x1f\0:\x04\xe8\xa0\x1f\0\"\xff\x01\n\x04Pool\x12o\n\
    \x11not_bonded_tokens\x18\x01\x20\x01(\tR\x0fnotBondedTokensBC\xc8\xde\
    \x1f\0\xea\xde\x1f\x11not_bonded_tokens\xda\xde\x1f&github.com/cosmos/co\
    smos-sdk/types.Int\x12|\n\rbonded_tokens\x18\x02\x20\x01(\tR\x0cbondedTo\
    kensBW\xea\xde\x1f\rbonded_tokens\xda\xde\x1f&github.com/cosmos/cosmos-s\
    dk/types.Int\xc8\xde\x1f\0\xf2\xde\x1f\x14yaml:\"bonded_tokens\":\x08\
    \xf0\xa0\x1f\x01\xe8\xa0\x1f\x01*\xb6\x01\n\nBondStatus\x12,\n\x17BOND_S\
    TATUS_UNSPECIFIED\x10\0\x1a\x0f\x8a\x9d\x20\x0bUnspecified\x12&\n\x14BON\
    D_STATUS_UNBONDED\x10\x01\x1a\x0c\x8a\x9d\x20\x08Unbonded\x12(\n\x15BOND\
    _STATUS_UNBONDING\x10\x02\x1a\r\x8a\x9d\x20\tUnbonding\x12\"\n\x12BOND_S\
    TATUS_BONDED\x10\x03\x1a\n\x8a\x9d\x20\x06Bonded\x1a\x04\x88\xa3\x1e\0B.\
    Z,github.com/cosmos/cosmos-sdk/x/staking/typesJ\xe5_\n\x07\x12\x05\0\0\
    \xa1\x02\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x01\
    \x08\x1e\n\t\n\x02\x03\0\x12\x03\x03\x07\x1d\n\t\n\x02\x03\x01\x12\x03\
    \x04\x07\"\n\t\n\x02\x03\x02\x12\x03\x05\x07'\n\t\n\x02\x03\x03\x12\x03\
    \x06\x07(\n\t\n\x02\x03\x04\x12\x03\x08\x07\"\n\t\n\x02\x03\x05\x12\x03\
    \t\x07'\n\t\n\x02\x03\x06\x12\x03\n\x07%\n\x08\n\x01\x08\x12\x03\x0c\0C\
    \n\t\n\x02\x08\x0b\x12\x03\x0c\0C\n\x84\x02\n\x02\x04\0\x12\x04\x12\0\
    \x15\x01\x1a\xf7\x01\x20HistoricalInfo\x20contains\x20header\x20and\x20v\
    alidator\x20information\x20for\x20a\x20given\x20block.\n\x20It\x20is\x20\
    stored\x20as\x20part\x20of\x20staking\x20module's\x20state,\x20which\x20\
    persists\x20the\x20`n`\x20most\n\x20recent\x20HistoricalInfo\n\x20(`n`\
    \x20is\x20set\x20by\x20the\x20staking\x20module's\x20`historical_entries\
    `\x20parameter).\n\n\n\n\x03\x04\0\x01\x12\x03\x12\x08\x16\n\x0b\n\x04\
    \x04\0\x02\0\x12\x03\x13\x02D\n\r\n\x05\x04\0\x02\0\x04\x12\x04\x13\x02\
    \x12\x18\n\x0c\n\x05\x04\0\x02\0\x06\x12\x03\x13\x02\x19\n\x0c\n\x05\x04\
    \0\x02\0\x01\x12\x03\x13\x1a\x20\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\x13\
    #$\n\x0c\n\x05\x04\0\x02\0\x08\x12\x03\x13%C\n\x0f\n\x08\x04\0\x02\0\x08\
    \xe9\xfb\x03\x12\x03\x13&B\n\x0b\n\x04\x04\0\x02\x01\x12\x03\x14\x02D\n\
    \x0c\n\x05\x04\0\x02\x01\x04\x12\x03\x14\x02\n\n\x0c\n\x05\x04\0\x02\x01\
    \x06\x12\x03\x14\x0b\x14\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\x14\x1a\
    \x20\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\x14#$\n\x0c\n\x05\x04\0\x02\
    \x01\x08\x12\x03\x14%C\n\x0f\n\x08\x04\0\x02\x01\x08\xe9\xfb\x03\x12\x03\
    \x14&B\nh\n\x02\x04\x01\x12\x04\x19\0(\x01\x1a\\\x20CommissionRates\x20d\
    efines\x20the\x20initial\x20commission\x20rates\x20to\x20be\x20used\x20f\
    or\x20creating\n\x20a\x20validator.\n\n\n\n\x03\x04\x01\x01\x12\x03\x19\
    \x08\x17\n\n\n\x03\x04\x01\x07\x12\x03\x1a\x02-\n\r\n\x06\x04\x01\x07\
    \x8d\xf4\x03\x12\x03\x1a\x02-\n\n\n\x03\x04\x01\x07\x12\x03\x1b\x02.\n\r\
    \n\x06\x04\x01\x07\x83\xf4\x03\x12\x03\x1b\x02.\n\x0b\n\x04\x04\x01\x02\
    \0\x12\x03\x1d\x02x\n\r\n\x05\x04\x01\x02\0\x04\x12\x04\x1d\x02\x1b.\n\
    \x0c\n\x05\x04\x01\x02\0\x05\x12\x03\x1d\x02\x08\n\x0c\n\x05\x04\x01\x02\
    \0\x01\x12\x03\x1d\t\r\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03\x1d\x14\x15\
    \n\x0c\n\x05\x04\x01\x02\0\x08\x12\x03\x1d\x16w\n\x0f\n\x08\x04\x01\x02\
    \0\x08\xeb\xfb\x03\x12\x03\x1d\x17X\n\x0f\n\x08\x04\x01\x02\0\x08\xe9\
    \xfb\x03\x12\x03\x1dZv\n\x0c\n\x04\x04\x01\x02\x01\x12\x04\x1e\x02\"\x04\
    \n\r\n\x05\x04\x01\x02\x01\x04\x12\x04\x1e\x02\x1dx\n\x0c\n\x05\x04\x01\
    \x02\x01\x05\x12\x03\x1e\x02\x08\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03\
    \x1e\t\x11\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03\x1e\x14\x15\n\r\n\x05\
    \x04\x01\x02\x01\x08\x12\x04\x1e\x16\"\x03\n\x0f\n\x08\x04\x01\x02\x01\
    \x08\xee\xfb\x03\x12\x03\x1f\x040\n\x0f\n\x08\x04\x01\x02\x01\x08\xeb\
    \xfb\x03\x12\x03\x20\x04E\n\x0f\n\x08\x04\x01\x02\x01\x08\xe9\xfb\x03\
    \x12\x03!\x04\"\n\x0c\n\x04\x04\x01\x02\x02\x12\x04#\x02'\x04\n\r\n\x05\
    \x04\x01\x02\x02\x04\x12\x04#\x02\"\x04\n\x0c\n\x05\x04\x01\x02\x02\x05\
    \x12\x03#\x02\x08\n\x0c\n\x05\x04\x01\x02\x02\x01\x12\x03#\t\x18\n\x0c\n\
    \x05\x04\x01\x02\x02\x03\x12\x03#\x1b\x1c\n\r\n\x05\x04\x01\x02\x02\x08\
    \x12\x04#\x1d'\x03\n\x0f\n\x08\x04\x01\x02\x02\x08\xee\xfb\x03\x12\x03$\
    \x047\n\x0f\n\x08\x04\x01\x02\x02\x08\xeb\xfb\x03\x12\x03%\x04E\n\x0f\n\
    \x08\x04\x01\x02\x02\x08\xe9\xfb\x03\x12\x03&\x04\"\nM\n\x02\x04\x02\x12\
    \x04+\02\x01\x1aA\x20Commission\x20defines\x20commission\x20parameters\
    \x20for\x20a\x20given\x20validator.\n\n\n\n\x03\x04\x02\x01\x12\x03+\x08\
    \x12\n\n\n\x03\x04\x02\x07\x12\x03,\x02-\n\r\n\x06\x04\x02\x07\x8d\xf4\
    \x03\x12\x03,\x02-\n\n\n\x03\x04\x02\x07\x12\x03-\x02.\n\r\n\x06\x04\x02\
    \x07\x83\xf4\x03\x12\x03-\x02.\n\x0b\n\x04\x04\x02\x02\0\x12\x03/\x02j\n\
    \r\n\x05\x04\x02\x02\0\x04\x12\x04/\x02-.\n\x0c\n\x05\x04\x02\x02\0\x06\
    \x12\x03/\x02\x11\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03/\x1c,\n\x0c\n\
    \x05\x04\x02\x02\0\x03\x12\x03//0\n\x0c\n\x05\x04\x02\x02\0\x08\x12\x03/\
    1i\n\x0f\n\x08\x04\x02\x02\0\x08\xea\xfb\x03\x12\x03/2J\n\x0f\n\x08\x04\
    \x02\x02\0\x08\xe9\xfb\x03\x12\x03/Lh\n\x0c\n\x04\x04\x02\x02\x01\x12\
    \x040\x021p\n\r\n\x05\x04\x02\x02\x01\x04\x12\x040\x02/j\n\x0c\n\x05\x04\
    \x02\x02\x01\x06\x12\x030\x02\x1b\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\
    \x030\x1c'\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x030/0\n\x0c\n\x05\x04\
    \x02\x02\x01\x08\x12\x031\x06o\n\x0f\n\x08\x04\x02\x02\x01\x08\xe9\xfb\
    \x03\x12\x031\x07#\n\x0f\n\x08\x04\x02\x02\x01\x08\xf2\xfb\x03\x12\x031%\
    ?\n\x0f\n\x08\x04\x02\x02\x01\x08\xee\xfb\x03\x12\x031An\n:\n\x02\x04\
    \x03\x12\x045\0>\x01\x1a.\x20Description\x20defines\x20a\x20validator\
    \x20description.\n\n\n\n\x03\x04\x03\x01\x12\x035\x08\x13\n\n\n\x03\x04\
    \x03\x07\x12\x036\x02-\n\r\n\x06\x04\x03\x07\x8d\xf4\x03\x12\x036\x02-\n\
    \n\n\x03\x04\x03\x07\x12\x037\x02.\n\r\n\x06\x04\x03\x07\x83\xf4\x03\x12\
    \x037\x02.\n\x0b\n\x04\x04\x03\x02\0\x12\x039\x02\x1e\n\r\n\x05\x04\x03\
    \x02\0\x04\x12\x049\x027.\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x039\x02\x08\
    \n\x0c\n\x05\x04\x03\x02\0\x01\x12\x039\t\x10\n\x0c\n\x05\x04\x03\x02\0\
    \x03\x12\x039\x1c\x1d\n\x0b\n\x04\x04\x03\x02\x01\x12\x03:\x02\x1e\n\r\n\
    \x05\x04\x03\x02\x01\x04\x12\x04:\x029\x1e\n\x0c\n\x05\x04\x03\x02\x01\
    \x05\x12\x03:\x02\x08\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\x03:\t\x11\n\
    \x0c\n\x05\x04\x03\x02\x01\x03\x12\x03:\x1c\x1d\n\x0b\n\x04\x04\x03\x02\
    \x02\x12\x03;\x02\x1e\n\r\n\x05\x04\x03\x02\x02\x04\x12\x04;\x02:\x1e\n\
    \x0c\n\x05\x04\x03\x02\x02\x05\x12\x03;\x02\x08\n\x0c\n\x05\x04\x03\x02\
    \x02\x01\x12\x03;\t\x10\n\x0c\n\x05\x04\x03\x02\x02\x03\x12\x03;\x1c\x1d\
    \n\x0b\n\x04\x04\x03\x02\x03\x12\x03<\x02S\n\r\n\x05\x04\x03\x02\x03\x04\
    \x12\x04<\x02;\x1e\n\x0c\n\x05\x04\x03\x02\x03\x05\x12\x03<\x02\x08\n\
    \x0c\n\x05\x04\x03\x02\x03\x01\x12\x03<\t\x19\n\x0c\n\x05\x04\x03\x02\
    \x03\x03\x12\x03<\x1c\x1d\n\x0c\n\x05\x04\x03\x02\x03\x08\x12\x03<\x1eR\
    \n\x0f\n\x08\x04\x03\x02\x03\x08\xee\xfb\x03\x12\x03<\x1fQ\n\x0b\n\x04\
    \x04\x03\x02\x04\x12\x03=\x02\x1e\n\r\n\x05\x04\x03\x02\x04\x04\x12\x04=\
    \x02<S\n\x0c\n\x05\x04\x03\x02\x04\x05\x12\x03=\x02\x08\n\x0c\n\x05\x04\
    \x03\x02\x04\x01\x12\x03=\t\x10\n\x0c\n\x05\x04\x03\x02\x04\x03\x12\x03=\
    \x1c\x1d\n\xb8\x04\n\x02\x04\x04\x12\x04H\0b\x01\x1a\xab\x04\x20Validato\
    r\x20defines\x20a\x20validator,\x20together\x20with\x20the\x20total\x20a\
    mount\x20of\x20the\n\x20Validator's\x20bond\x20shares\x20and\x20their\
    \x20exchange\x20rate\x20to\x20coins.\x20Slashing\x20results\x20in\n\x20a\
    \x20decrease\x20in\x20the\x20exchange\x20rate,\x20allowing\x20correct\
    \x20calculation\x20of\x20future\n\x20undelegations\x20without\x20iterati\
    ng\x20over\x20delegators.\x20When\x20coins\x20are\x20delegated\x20to\n\
    \x20this\x20validator,\x20the\x20validator\x20is\x20credited\x20with\x20\
    a\x20delegation\x20whose\x20number\x20of\n\x20bond\x20shares\x20is\x20ba\
    sed\x20on\x20the\x20amount\x20of\x20coins\x20delegated\x20divided\x20by\
    \x20the\x20current\n\x20exchange\x20rate.\x20Voting\x20power\x20can\x20b\
    e\x20calculated\x20as\x20total\x20bonded\x20shares\n\x20multiplied\x20by\
    \x20exchange\x20rate.\n\n\n\n\x03\x04\x04\x01\x12\x03H\x08\x11\n\n\n\x03\
    \x04\x04\x07\x12\x03I\x02.\n\r\n\x06\x04\x04\x07\x8d\xf4\x03\x12\x03I\
    \x02.\n\n\n\x03\x04\x04\x07\x12\x03J\x02.\n\r\n\x06\x04\x04\x07\x83\xf4\
    \x03\x12\x03J\x02.\n\n\n\x03\x04\x04\x07\x12\x03K\x02.\n\r\n\x06\x04\x04\
    \x07\x81\xf4\x03\x12\x03K\x02.\n\x0b\n\x04\x04\x04\x02\0\x12\x03M\x02`\n\
    \r\n\x05\x04\x04\x02\0\x04\x12\x04M\x02K.\n\x0c\n\x05\x04\x04\x02\0\x05\
    \x12\x03M\x02\x08\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03M\x16&\n\x0c\n\
    \x05\x04\x04\x02\0\x03\x12\x03M)*\n\x0c\n\x05\x04\x04\x02\0\x08\x12\x03M\
    +_\n\x0f\n\x08\x04\x04\x02\0\x08\xee\xfb\x03\x12\x03M,^\n\x0c\n\x04\x04\
    \x04\x02\x01\x12\x04N\x02Ov\n\r\n\x05\x04\x04\x02\x01\x04\x12\x04N\x02M`\
    \n\x0c\n\x05\x04\x04\x02\x01\x06\x12\x03N\x02\x15\n\x0c\n\x05\x04\x04\
    \x02\x01\x01\x12\x03N\x16&\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\x03N)*\n\
    \x0c\n\x05\x04\x04\x02\x01\x08\x12\x03O\x06u\n\x0f\n\x08\x04\x04\x02\x01\
    \x08\xc9\xd6\x05\x12\x03O\x07@\n\x0f\n\x08\x04\x04\x02\x01\x08\xee\xfb\
    \x03\x12\x03OBt\n\x0b\n\x04\x04\x04\x02\x02\x12\x03P\x02\x18\n\r\n\x05\
    \x04\x04\x02\x02\x04\x12\x04P\x02Ov\n\x0c\n\x05\x04\x04\x02\x02\x05\x12\
    \x03P\x02\x06\n\x0c\n\x05\x04\x04\x02\x02\x01\x12\x03P\r\x13\n\x0c\n\x05\
    \x04\x04\x02\x02\x03\x12\x03P\x16\x17\n\x0b\n\x04\x04\x04\x02\x03\x12\
    \x03Q\x02\x18\n\r\n\x05\x04\x04\x02\x03\x04\x12\x04Q\x02P\x18\n\x0c\n\
    \x05\x04\x04\x02\x03\x06\x12\x03Q\x02\x0c\n\x0c\n\x05\x04\x04\x02\x03\
    \x01\x12\x03Q\r\x13\n\x0c\n\x05\x04\x04\x02\x03\x03\x12\x03Q\x16\x17\n\
    \x0b\n\x04\x04\x04\x02\x04\x12\x03R\x02v\n\r\n\x05\x04\x04\x02\x04\x04\
    \x12\x04R\x02Q\x18\n\x0c\n\x05\x04\x04\x02\x04\x05\x12\x03R\x02\x08\n\
    \x0c\n\x05\x04\x04\x02\x04\x01\x12\x03R\t\x0f\n\x0c\n\x05\x04\x04\x02\
    \x04\x03\x12\x03R\x12\x13\n\x0c\n\x05\x04\x04\x02\x04\x08\x12\x03R\x14u\
    \n\x0f\n\x08\x04\x04\x02\x04\x08\xeb\xfb\x03\x12\x03R\x15V\n\x0f\n\x08\
    \x04\x04\x02\x04\x08\xe9\xfb\x03\x12\x03RXt\n\x0c\n\x04\x04\x04\x02\x05\
    \x12\x04S\x02W\x04\n\r\n\x05\x04\x04\x02\x05\x04\x12\x04S\x02Rv\n\x0c\n\
    \x05\x04\x04\x02\x05\x05\x12\x03S\x02\x08\n\x0c\n\x05\x04\x04\x02\x05\
    \x01\x12\x03S\t\x19\n\x0c\n\x05\x04\x04\x02\x05\x03\x12\x03S\x1c\x1d\n\r\
    \n\x05\x04\x04\x02\x05\x08\x12\x04S\x1eW\x03\n\x0f\n\x08\x04\x04\x02\x05\
    \x08\xee\xfb\x03\x12\x03T\x048\n\x0f\n\x08\x04\x04\x02\x05\x08\xeb\xfb\
    \x03\x12\x03U\x04E\n\x0f\n\x08\x04\x04\x02\x05\x08\xe9\xfb\x03\x12\x03V\
    \x04\"\n\x0b\n\x04\x04\x04\x02\x06\x12\x03X\x02P\n\r\n\x05\x04\x04\x02\
    \x06\x04\x12\x04X\x02W\x04\n\x0c\n\x05\x04\x04\x02\x06\x06\x12\x03X\x02\
    \r\n\x0c\n\x05\x04\x04\x02\x06\x01\x12\x03X\x1c'\n\x0c\n\x05\x04\x04\x02\
    \x06\x03\x12\x03X/0\n\x0c\n\x05\x04\x04\x02\x06\x08\x12\x03X1O\n\x0f\n\
    \x08\x04\x04\x02\x06\x08\xe9\xfb\x03\x12\x03X2N\n\x0b\n\x04\x04\x04\x02\
    \x07\x12\x03Y\x02f\n\r\n\x05\x04\x04\x02\x07\x04\x12\x04Y\x02XP\n\x0c\n\
    \x05\x04\x04\x02\x07\x05\x12\x03Y\x02\x07\n\x0c\n\x05\x04\x04\x02\x07\
    \x01\x12\x03Y\x1c,\n\x0c\n\x05\x04\x04\x02\x07\x03\x12\x03Y/0\n\x0c\n\
    \x05\x04\x04\x02\x07\x08\x12\x03Y1e\n\x0f\n\x08\x04\x04\x02\x07\x08\xee\
    \xfb\x03\x12\x03Y2d\n\x0c\n\x04\x04\x04\x02\x08\x12\x04Z\x02[s\n\r\n\x05\
    \x04\x04\x02\x08\x04\x12\x04Z\x02Yf\n\x0c\n\x05\x04\x04\x02\x08\x06\x12\
    \x03Z\x02\x1b\n\x0c\n\x05\x04\x04\x02\x08\x01\x12\x03Z\x1c*\n\x0c\n\x05\
    \x04\x04\x02\x08\x03\x12\x03Z/0\n\x0c\n\x05\x04\x04\x02\x08\x08\x12\x03[\
    \x06r\n\x0f\n\x08\x04\x04\x02\x08\x08\xe9\xfb\x03\x12\x03[\x07#\n\x0f\n\
    \x08\x04\x04\x02\x08\x08\xf2\xfb\x03\x12\x03[%?\n\x0f\n\x08\x04\x04\x02\
    \x08\x08\xee\xfb\x03\x12\x03[Aq\n\x0b\n\x04\x04\x04\x02\t\x12\x03\\\x02E\
    \n\r\n\x05\x04\x04\x02\t\x04\x12\x04\\\x02[s\n\x0c\n\x05\x04\x04\x02\t\
    \x06\x12\x03\\\x02\x0c\n\x0c\n\x05\x04\x04\x02\t\x01\x12\x03\\\r\x17\n\
    \x0c\n\x05\x04\x04\x02\t\x03\x12\x03\\#%\n\x0c\n\x05\x04\x04\x02\t\x08\
    \x12\x03\\&D\n\x0f\n\x08\x04\x04\x02\t\x08\xe9\xfb\x03\x12\x03\\'C\n\x0c\
    \n\x04\x04\x04\x02\n\x12\x04]\x02a\x04\n\r\n\x05\x04\x04\x02\n\x04\x12\
    \x04]\x02\\E\n\x0c\n\x05\x04\x04\x02\n\x05\x12\x03]\x02\x08\n\x0c\n\x05\
    \x04\x04\x02\n\x01\x12\x03]\r\x20\n\x0c\n\x05\x04\x04\x02\n\x03\x12\x03]\
    #%\n\r\n\x05\x04\x04\x02\n\x08\x12\x04]&a\x03\n\x0f\n\x08\x04\x04\x02\n\
    \x08\xee\xfb\x03\x12\x03^\x04;\n\x0f\n\x08\x04\x04\x02\n\x08\xeb\xfb\x03\
    \x12\x03_\x04E\n\x0f\n\x08\x04\x04\x02\n\x08\xe9\xfb\x03\x12\x03`\x04\"\
    \n6\n\x02\x05\0\x12\x04e\0p\x01\x1a*\x20BondStatus\x20is\x20the\x20statu\
    s\x20of\x20a\x20validator.\n\n\n\n\x03\x05\0\x01\x12\x03e\x05\x0f\n\n\n\
    \x03\x05\0\x03\x12\x03f\x021\n\r\n\x06\x05\0\x03\xb1\xe4\x03\x12\x03f\
    \x021\n?\n\x04\x05\0\x02\0\x12\x03i\x02Q\x1a2\x20UNSPECIFIED\x20defines\
    \x20an\x20invalid\x20validator\x20status.\n\n\x0c\n\x05\x05\0\x02\0\x01\
    \x12\x03i\x02\x19\n\x0c\n\x05\x05\0\x02\0\x02\x12\x03i\x1c\x1d\n\x0c\n\
    \x05\x05\0\x02\0\x03\x12\x03i\x1eP\n\x0f\n\x08\x05\0\x02\0\x03\xd1\x83\
    \x04\x12\x03i\x1fO\n?\n\x04\x05\0\x02\x01\x12\x03k\x02K\x1a2\x20UNBONDED\
    \x20defines\x20a\x20validator\x20that\x20is\x20not\x20bonded.\n\n\x0c\n\
    \x05\x05\0\x02\x01\x01\x12\x03k\x02\x16\n\x0c\n\x05\x05\0\x02\x01\x02\
    \x12\x03k\x19\x1a\n\x0c\n\x05\x05\0\x02\x01\x03\x12\x03k\x1bJ\n\x0f\n\
    \x08\x05\0\x02\x01\x03\xd1\x83\x04\x12\x03k\x1cI\n?\n\x04\x05\0\x02\x02\
    \x12\x03m\x02M\x1a2\x20UNBONDING\x20defines\x20a\x20validator\x20that\
    \x20is\x20unbonding.\n\n\x0c\n\x05\x05\0\x02\x02\x01\x12\x03m\x02\x17\n\
    \x0c\n\x05\x05\0\x02\x02\x02\x12\x03m\x1a\x1b\n\x0c\n\x05\x05\0\x02\x02\
    \x03\x12\x03m\x1cL\n\x0f\n\x08\x05\0\x02\x02\x03\xd1\x83\x04\x12\x03m\
    \x1dK\n9\n\x04\x05\0\x02\x03\x12\x03o\x02G\x1a,\x20BONDED\x20defines\x20\
    a\x20validator\x20that\x20is\x20bonded.\n\n\x0c\n\x05\x05\0\x02\x03\x01\
    \x12\x03o\x02\x14\n\x0c\n\x05\x05\0\x02\x03\x02\x12\x03o\x17\x18\n\x0c\n\
    \x05\x05\0\x02\x03\x03\x12\x03o\x19F\n\x0f\n\x08\x05\0\x02\x03\x03\xd1\
    \x83\x04\x12\x03o\x1aE\nI\n\x02\x04\x05\x12\x04s\0x\x01\x1a=\x20ValAddre\
    sses\x20defines\x20a\x20repeated\x20set\x20of\x20validator\x20addresses.\
    \n\n\n\n\x03\x04\x05\x01\x12\x03s\x08\x14\n\n\n\x03\x04\x05\x07\x12\x03t\
    \x02.\n\r\n\x06\x04\x05\x07\x83\xf4\x03\x12\x03t\x02.\n\n\n\x03\x04\x05\
    \x07\x12\x03u\x02-\n\r\n\x06\x04\x05\x07\xc0\x8b\x04\x12\x03u\x02-\n\x0b\
    \n\x04\x04\x05\x02\0\x12\x03w\x02\x20\n\x0c\n\x05\x04\x05\x02\0\x04\x12\
    \x03w\x02\n\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x03w\x0b\x11\n\x0c\n\x05\
    \x04\x05\x02\0\x01\x12\x03w\x12\x1b\n\x0c\n\x05\x04\x05\x02\0\x03\x12\
    \x03w\x1e\x1f\n\xf8\x01\n\x02\x04\x06\x12\x05}\0\x84\x01\x01\x1a\xea\x01\
    \x20DVPair\x20is\x20struct\x20that\x20just\x20has\x20a\x20delegator-vali\
    dator\x20pair\x20with\x20no\x20other\x20data.\n\x20It\x20is\x20intended\
    \x20to\x20be\x20used\x20as\x20a\x20marshalable\x20pointer.\x20For\x20exa\
    mple,\x20a\x20DVPair\x20can\n\x20be\x20used\x20to\x20construct\x20the\
    \x20key\x20to\x20getting\x20an\x20UnbondingDelegation\x20from\x20state.\
    \n\n\n\n\x03\x04\x06\x01\x12\x03}\x08\x0e\n\n\n\x03\x04\x06\x07\x12\x03~\
    \x02.\n\r\n\x06\x04\x06\x07\x8d\xf4\x03\x12\x03~\x02.\n\n\n\x03\x04\x06\
    \x07\x12\x03\x7f\x02.\n\r\n\x06\x04\x06\x07\x81\xf4\x03\x12\x03\x7f\x02.\
    \n\x0b\n\x03\x04\x06\x07\x12\x04\x80\x01\x02.\n\x0e\n\x06\x04\x06\x07\
    \x83\xf4\x03\x12\x04\x80\x01\x02.\n\x0c\n\x04\x04\x06\x02\0\x12\x04\x82\
    \x01\x02U\n\x0f\n\x05\x04\x06\x02\0\x04\x12\x06\x82\x01\x02\x80\x01.\n\r\
    \n\x05\x04\x06\x02\0\x05\x12\x04\x82\x01\x02\x08\n\r\n\x05\x04\x06\x02\0\
    \x01\x12\x04\x82\x01\t\x1a\n\r\n\x05\x04\x06\x02\0\x03\x12\x04\x82\x01\
    \x1d\x1e\n\r\n\x05\x04\x06\x02\0\x08\x12\x04\x82\x01\x1fT\n\x10\n\x08\
    \x04\x06\x02\0\x08\xee\xfb\x03\x12\x04\x82\x01\x20S\n\x0c\n\x04\x04\x06\
    \x02\x01\x12\x04\x83\x01\x02U\n\x0f\n\x05\x04\x06\x02\x01\x04\x12\x06\
    \x83\x01\x02\x82\x01U\n\r\n\x05\x04\x06\x02\x01\x05\x12\x04\x83\x01\x02\
    \x08\n\r\n\x05\x04\x06\x02\x01\x01\x12\x04\x83\x01\t\x1a\n\r\n\x05\x04\
    \x06\x02\x01\x03\x12\x04\x83\x01\x1d\x1e\n\r\n\x05\x04\x06\x02\x01\x08\
    \x12\x04\x83\x01\x1fT\n\x10\n\x08\x04\x06\x02\x01\x08\xee\xfb\x03\x12\
    \x04\x83\x01\x20S\n;\n\x02\x04\x07\x12\x06\x87\x01\0\x89\x01\x01\x1a-\
    \x20DVPairs\x20defines\x20an\x20array\x20of\x20DVPair\x20objects.\n\n\
    \x0b\n\x03\x04\x07\x01\x12\x04\x87\x01\x08\x0f\n\x0c\n\x04\x04\x07\x02\0\
    \x12\x04\x88\x01\x02;\n\r\n\x05\x04\x07\x02\0\x04\x12\x04\x88\x01\x02\n\
    \n\r\n\x05\x04\x07\x02\0\x06\x12\x04\x88\x01\x0b\x11\n\r\n\x05\x04\x07\
    \x02\0\x01\x12\x04\x88\x01\x12\x17\n\r\n\x05\x04\x07\x02\0\x03\x12\x04\
    \x88\x01\x1a\x1b\n\r\n\x05\x04\x07\x02\0\x08\x12\x04\x88\x01\x1c:\n\x10\
    \n\x08\x04\x07\x02\0\x08\xe9\xfb\x03\x12\x04\x88\x01\x1d9\n\x87\x02\n\
    \x02\x04\x08\x12\x06\x8f\x01\0\x97\x01\x01\x1a\xf8\x01\x20DVVTriplet\x20\
    is\x20struct\x20that\x20just\x20has\x20a\x20delegator-validator-validato\
    r\x20triplet\n\x20with\x20no\x20other\x20data.\x20It\x20is\x20intended\
    \x20to\x20be\x20used\x20as\x20a\x20marshalable\x20pointer.\x20For\n\x20e\
    xample,\x20a\x20DVVTriplet\x20can\x20be\x20used\x20to\x20construct\x20th\
    e\x20key\x20to\x20getting\x20a\n\x20Redelegation\x20from\x20state.\n\n\
    \x0b\n\x03\x04\x08\x01\x12\x04\x8f\x01\x08\x12\n\x0b\n\x03\x04\x08\x07\
    \x12\x04\x90\x01\x02.\n\x0e\n\x06\x04\x08\x07\x8d\xf4\x03\x12\x04\x90\
    \x01\x02.\n\x0b\n\x03\x04\x08\x07\x12\x04\x91\x01\x02.\n\x0e\n\x06\x04\
    \x08\x07\x81\xf4\x03\x12\x04\x91\x01\x02.\n\x0b\n\x03\x04\x08\x07\x12\
    \x04\x92\x01\x02.\n\x0e\n\x06\x04\x08\x07\x83\xf4\x03\x12\x04\x92\x01\
    \x02.\n\x0c\n\x04\x04\x08\x02\0\x12\x04\x94\x01\x02Y\n\x0f\n\x05\x04\x08\
    \x02\0\x04\x12\x06\x94\x01\x02\x92\x01.\n\r\n\x05\x04\x08\x02\0\x05\x12\
    \x04\x94\x01\x02\x08\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\x94\x01\t\x1a\n\
    \r\n\x05\x04\x08\x02\0\x03\x12\x04\x94\x01!\"\n\r\n\x05\x04\x08\x02\0\
    \x08\x12\x04\x94\x01#X\n\x10\n\x08\x04\x08\x02\0\x08\xee\xfb\x03\x12\x04\
    \x94\x01$W\n\x0c\n\x04\x04\x08\x02\x01\x12\x04\x95\x01\x02]\n\x0f\n\x05\
    \x04\x08\x02\x01\x04\x12\x06\x95\x01\x02\x94\x01Y\n\r\n\x05\x04\x08\x02\
    \x01\x05\x12\x04\x95\x01\x02\x08\n\r\n\x05\x04\x08\x02\x01\x01\x12\x04\
    \x95\x01\t\x1e\n\r\n\x05\x04\x08\x02\x01\x03\x12\x04\x95\x01!\"\n\r\n\
    \x05\x04\x08\x02\x01\x08\x12\x04\x95\x01#\\\n\x10\n\x08\x04\x08\x02\x01\
    \x08\xee\xfb\x03\x12\x04\x95\x01$[\n\x0c\n\x04\x04\x08\x02\x02\x12\x04\
    \x96\x01\x02]\n\x0f\n\x05\x04\x08\x02\x02\x04\x12\x06\x96\x01\x02\x95\
    \x01]\n\r\n\x05\x04\x08\x02\x02\x05\x12\x04\x96\x01\x02\x08\n\r\n\x05\
    \x04\x08\x02\x02\x01\x12\x04\x96\x01\t\x1e\n\r\n\x05\x04\x08\x02\x02\x03\
    \x12\x04\x96\x01!\"\n\r\n\x05\x04\x08\x02\x02\x08\x12\x04\x96\x01#\\\n\
    \x10\n\x08\x04\x08\x02\x02\x08\xee\xfb\x03\x12\x04\x96\x01$[\nC\n\x02\
    \x04\t\x12\x06\x9a\x01\0\x9c\x01\x01\x1a5\x20DVVTriplets\x20defines\x20a\
    n\x20array\x20of\x20DVVTriplet\x20objects.\n\n\x0b\n\x03\x04\t\x01\x12\
    \x04\x9a\x01\x08\x13\n\x0c\n\x04\x04\t\x02\0\x12\x04\x9b\x01\x02B\n\r\n\
    \x05\x04\t\x02\0\x04\x12\x04\x9b\x01\x02\n\n\r\n\x05\x04\t\x02\0\x06\x12\
    \x04\x9b\x01\x0b\x15\n\r\n\x05\x04\t\x02\0\x01\x12\x04\x9b\x01\x16\x1e\n\
    \r\n\x05\x04\t\x02\0\x03\x12\x04\x9b\x01!\"\n\r\n\x05\x04\t\x02\0\x08\
    \x12\x04\x9b\x01#A\n\x10\n\x08\x04\t\x02\0\x08\xe9\xfb\x03\x12\x04\x9b\
    \x01$@\n\xa9\x01\n\x02\x04\n\x12\x06\xa1\x01\0\xa9\x01\x01\x1a\x9a\x01\
    \x20Delegation\x20represents\x20the\x20bond\x20with\x20tokens\x20held\
    \x20by\x20an\x20account.\x20It\x20is\n\x20owned\x20by\x20one\x20delegato\
    r,\x20and\x20is\x20associated\x20with\x20the\x20voting\x20power\x20of\
    \x20one\n\x20validator.\n\n\x0b\n\x03\x04\n\x01\x12\x04\xa1\x01\x08\x12\
    \n\x0b\n\x03\x04\n\x07\x12\x04\xa2\x01\x02.\n\x0e\n\x06\x04\n\x07\x8d\
    \xf4\x03\x12\x04\xa2\x01\x02.\n\x0b\n\x03\x04\n\x07\x12\x04\xa3\x01\x02.\
    \n\x0e\n\x06\x04\n\x07\x81\xf4\x03\x12\x04\xa3\x01\x02.\n\x0b\n\x03\x04\
    \n\x07\x12\x04\xa4\x01\x02.\n\x0e\n\x06\x04\n\x07\x83\xf4\x03\x12\x04\
    \xa4\x01\x02.\n\x0c\n\x04\x04\n\x02\0\x12\x04\xa6\x01\x02U\n\x0f\n\x05\
    \x04\n\x02\0\x04\x12\x06\xa6\x01\x02\xa4\x01.\n\r\n\x05\x04\n\x02\0\x05\
    \x12\x04\xa6\x01\x02\x08\n\r\n\x05\x04\n\x02\0\x01\x12\x04\xa6\x01\t\x1a\
    \n\r\n\x05\x04\n\x02\0\x03\x12\x04\xa6\x01\x1d\x1e\n\r\n\x05\x04\n\x02\0\
    \x08\x12\x04\xa6\x01\x1fT\n\x10\n\x08\x04\n\x02\0\x08\xee\xfb\x03\x12\
    \x04\xa6\x01\x20S\n\x0c\n\x04\x04\n\x02\x01\x12\x04\xa7\x01\x02U\n\x0f\n\
    \x05\x04\n\x02\x01\x04\x12\x06\xa7\x01\x02\xa6\x01U\n\r\n\x05\x04\n\x02\
    \x01\x05\x12\x04\xa7\x01\x02\x08\n\r\n\x05\x04\n\x02\x01\x01\x12\x04\xa7\
    \x01\t\x1a\n\r\n\x05\x04\n\x02\x01\x03\x12\x04\xa7\x01\x1d\x1e\n\r\n\x05\
    \x04\n\x02\x01\x08\x12\x04\xa7\x01\x1fT\n\x10\n\x08\x04\n\x02\x01\x08\
    \xee\xfb\x03\x12\x04\xa7\x01\x20S\n\x0c\n\x04\x04\n\x02\x02\x12\x04\xa8\
    \x01\x02v\n\x0f\n\x05\x04\n\x02\x02\x04\x12\x06\xa8\x01\x02\xa7\x01U\n\r\
    \n\x05\x04\n\x02\x02\x05\x12\x04\xa8\x01\x02\x08\n\r\n\x05\x04\n\x02\x02\
    \x01\x12\x04\xa8\x01\t\x0f\n\r\n\x05\x04\n\x02\x02\x03\x12\x04\xa8\x01\
    \x12\x13\n\r\n\x05\x04\n\x02\x02\x08\x12\x04\xa8\x01\x14u\n\x10\n\x08\
    \x04\n\x02\x02\x08\xeb\xfb\x03\x12\x04\xa8\x01\x15V\n\x10\n\x08\x04\n\
    \x02\x02\x08\xe9\xfb\x03\x12\x04\xa8\x01Xt\n\x87\x01\n\x02\x04\x0b\x12\
    \x06\xad\x01\0\xb5\x01\x01\x1ay\x20UnbondingDelegation\x20stores\x20all\
    \x20of\x20a\x20single\x20delegator's\x20unbonding\x20bonds\n\x20for\x20a\
    \x20single\x20validator\x20in\x20an\x20time-ordered\x20list.\n\n\x0b\n\
    \x03\x04\x0b\x01\x12\x04\xad\x01\x08\x1b\n\x0b\n\x03\x04\x0b\x07\x12\x04\
    \xae\x01\x02.\n\x0e\n\x06\x04\x0b\x07\x8d\xf4\x03\x12\x04\xae\x01\x02.\n\
    \x0b\n\x03\x04\x0b\x07\x12\x04\xaf\x01\x02.\n\x0e\n\x06\x04\x0b\x07\x81\
    \xf4\x03\x12\x04\xaf\x01\x02.\n\x0b\n\x03\x04\x0b\x07\x12\x04\xb0\x01\
    \x02.\n\x0e\n\x06\x04\x0b\x07\x83\xf4\x03\x12\x04\xb0\x01\x02.\n\x0c\n\
    \x04\x04\x0b\x02\0\x12\x04\xb2\x01\x02p\n\x0f\n\x05\x04\x0b\x02\0\x04\
    \x12\x06\xb2\x01\x02\xb0\x01.\n\r\n\x05\x04\x0b\x02\0\x05\x12\x04\xb2\
    \x01\x02\x08\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\xb2\x01$5\n\r\n\x05\x04\
    \x0b\x02\0\x03\x12\x04\xb2\x0189\n\r\n\x05\x04\x0b\x02\0\x08\x12\x04\xb2\
    \x01:o\n\x10\n\x08\x04\x0b\x02\0\x08\xee\xfb\x03\x12\x04\xb2\x01;n\n\x0c\
    \n\x04\x04\x0b\x02\x01\x12\x04\xb3\x01\x02p\n\x0f\n\x05\x04\x0b\x02\x01\
    \x04\x12\x06\xb3\x01\x02\xb2\x01p\n\r\n\x05\x04\x0b\x02\x01\x05\x12\x04\
    \xb3\x01\x02\x08\n\r\n\x05\x04\x0b\x02\x01\x01\x12\x04\xb3\x01$5\n\r\n\
    \x05\x04\x0b\x02\x01\x03\x12\x04\xb3\x0189\n\r\n\x05\x04\x0b\x02\x01\x08\
    \x12\x04\xb3\x01:o\n\x10\n\x08\x04\x0b\x02\x01\x08\xee\xfb\x03\x12\x04\
    \xb3\x01;n\n,\n\x04\x04\x0b\x02\x02\x12\x04\xb4\x01\x02O\"\x1e\x20unbond\
    ing\x20delegation\x20entries\n\n\r\n\x05\x04\x0b\x02\x02\x04\x12\x04\xb4\
    \x01\x02\n\n\r\n\x05\x04\x0b\x02\x02\x06\x12\x04\xb4\x01\x0b#\n\r\n\x05\
    \x04\x0b\x02\x02\x01\x12\x04\xb4\x01$+\n\r\n\x05\x04\x0b\x02\x02\x03\x12\
    \x04\xb4\x01./\n\r\n\x05\x04\x0b\x02\x02\x08\x12\x04\xb4\x010N\n\x10\n\
    \x08\x04\x0b\x02\x02\x08\xe9\xfb\x03\x12\x04\xb4\x011M\n\\\n\x02\x04\x0c\
    \x12\x06\xb8\x01\0\xc5\x01\x01\x1aN\x20UnbondingDelegationEntry\x20defin\
    es\x20an\x20unbonding\x20object\x20with\x20relevant\x20metadata.\n\n\x0b\
    \n\x03\x04\x0c\x01\x12\x04\xb8\x01\x08\x20\n\x0b\n\x03\x04\x0c\x07\x12\
    \x04\xb9\x01\x02-\n\x0e\n\x06\x04\x0c\x07\x8d\xf4\x03\x12\x04\xb9\x01\
    \x02-\n\x0b\n\x03\x04\x0c\x07\x12\x04\xba\x01\x02.\n\x0e\n\x06\x04\x0c\
    \x07\x83\xf4\x03\x12\x04\xba\x01\x02.\n\x0c\n\x04\x04\x0c\x02\0\x12\x04\
    \xbc\x01\x02d\n\x0f\n\x05\x04\x0c\x02\0\x04\x12\x06\xbc\x01\x02\xba\x01.\
    \n\r\n\x05\x04\x0c\x02\0\x05\x12\x04\xbc\x01\x02\x07\n\r\n\x05\x04\x0c\
    \x02\0\x01\x12\x04\xbc\x01\x1c+\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\xbc\
    \x01./\n\r\n\x05\x04\x0c\x02\0\x08\x12\x04\xbc\x010c\n\x10\n\x08\x04\x0c\
    \x02\0\x08\xee\xfb\x03\x12\x04\xbc\x011b\n\x0e\n\x04\x04\x0c\x02\x01\x12\
    \x06\xbd\x01\x02\xbe\x01t\n\x0f\n\x05\x04\x0c\x02\x01\x04\x12\x06\xbd\
    \x01\x02\xbc\x01d\n\r\n\x05\x04\x0c\x02\x01\x06\x12\x04\xbd\x01\x02\x1b\
    \n\r\n\x05\x04\x0c\x02\x01\x01\x12\x04\xbd\x01\x1c+\n\r\n\x05\x04\x0c\
    \x02\x01\x03\x12\x04\xbd\x01./\n\r\n\x05\x04\x0c\x02\x01\x08\x12\x04\xbe\
    \x01\x06s\n\x10\n\x08\x04\x0c\x02\x01\x08\xe9\xfb\x03\x12\x04\xbe\x01\
    \x07#\n\x10\n\x08\x04\x0c\x02\x01\x08\xf2\xfb\x03\x12\x04\xbe\x01%?\n\
    \x10\n\x08\x04\x0c\x02\x01\x08\xee\xfb\x03\x12\x04\xbe\x01Ar\n\x0e\n\x04\
    \x04\x0c\x02\x02\x12\x06\xbf\x01\x02\xc3\x01\x04\n\x0f\n\x05\x04\x0c\x02\
    \x02\x04\x12\x06\xbf\x01\x02\xbe\x01t\n\r\n\x05\x04\x0c\x02\x02\x05\x12\
    \x04\xbf\x01\x02\x08\n\r\n\x05\x04\x0c\x02\x02\x01\x12\x04\xbf\x01\t\x18\
    \n\r\n\x05\x04\x0c\x02\x02\x03\x12\x04\xbf\x01\x1b\x1c\n\x0f\n\x05\x04\
    \x0c\x02\x02\x08\x12\x06\xbf\x01\x1d\xc3\x01\x03\n\x10\n\x08\x04\x0c\x02\
    \x02\x08\xeb\xfb\x03\x12\x04\xc0\x01\x04E\n\x10\n\x08\x04\x0c\x02\x02\
    \x08\xe9\xfb\x03\x12\x04\xc1\x01\x04\"\n\x10\n\x08\x04\x0c\x02\x02\x08\
    \xee\xfb\x03\x12\x04\xc2\x01\x047\n\x0c\n\x04\x04\x0c\x02\x03\x12\x04\
    \xc4\x01\x02w\n\x0f\n\x05\x04\x0c\x02\x03\x04\x12\x06\xc4\x01\x02\xc3\
    \x01\x04\n\r\n\x05\x04\x0c\x02\x03\x05\x12\x04\xc4\x01\x02\x08\n\r\n\x05\
    \x04\x0c\x02\x03\x01\x12\x04\xc4\x01\t\x10\n\r\n\x05\x04\x0c\x02\x03\x03\
    \x12\x04\xc4\x01\x13\x14\n\r\n\x05\x04\x0c\x02\x03\x08\x12\x04\xc4\x01\
    \x15v\n\x10\n\x08\x04\x0c\x02\x03\x08\xeb\xfb\x03\x12\x04\xc4\x01\x16W\n\
    \x10\n\x08\x04\x0c\x02\x03\x08\xe9\xfb\x03\x12\x04\xc4\x01Yu\nW\n\x02\
    \x04\r\x12\x06\xc8\x01\0\xd6\x01\x01\x1aI\x20RedelegationEntry\x20define\
    s\x20a\x20redelegation\x20object\x20with\x20relevant\x20metadata.\n\n\
    \x0b\n\x03\x04\r\x01\x12\x04\xc8\x01\x08\x19\n\x0b\n\x03\x04\r\x07\x12\
    \x04\xc9\x01\x02-\n\x0e\n\x06\x04\r\x07\x8d\xf4\x03\x12\x04\xc9\x01\x02-\
    \n\x0b\n\x03\x04\r\x07\x12\x04\xca\x01\x02.\n\x0e\n\x06\x04\r\x07\x83\
    \xf4\x03\x12\x04\xca\x01\x02.\n\x0c\n\x04\x04\r\x02\0\x12\x04\xcc\x01\
    \x02d\n\x0f\n\x05\x04\r\x02\0\x04\x12\x06\xcc\x01\x02\xca\x01.\n\r\n\x05\
    \x04\r\x02\0\x05\x12\x04\xcc\x01\x02\x07\n\r\n\x05\x04\r\x02\0\x01\x12\
    \x04\xcc\x01\x1c+\n\r\n\x05\x04\r\x02\0\x03\x12\x04\xcc\x01./\n\r\n\x05\
    \x04\r\x02\0\x08\x12\x04\xcc\x010c\n\x10\n\x08\x04\r\x02\0\x08\xee\xfb\
    \x03\x12\x04\xcc\x011b\n\x0e\n\x04\x04\r\x02\x01\x12\x06\xcd\x01\x02\xce\
    \x01t\n\x0f\n\x05\x04\r\x02\x01\x04\x12\x06\xcd\x01\x02\xcc\x01d\n\r\n\
    \x05\x04\r\x02\x01\x06\x12\x04\xcd\x01\x02\x1b\n\r\n\x05\x04\r\x02\x01\
    \x01\x12\x04\xcd\x01\x1c+\n\r\n\x05\x04\r\x02\x01\x03\x12\x04\xcd\x01./\
    \n\r\n\x05\x04\r\x02\x01\x08\x12\x04\xce\x01\x06s\n\x10\n\x08\x04\r\x02\
    \x01\x08\xe9\xfb\x03\x12\x04\xce\x01\x07#\n\x10\n\x08\x04\r\x02\x01\x08\
    \xf2\xfb\x03\x12\x04\xce\x01%?\n\x10\n\x08\x04\r\x02\x01\x08\xee\xfb\x03\
    \x12\x04\xce\x01Ar\n\x0e\n\x04\x04\r\x02\x02\x12\x06\xcf\x01\x02\xd3\x01\
    \x04\n\x0f\n\x05\x04\r\x02\x02\x04\x12\x06\xcf\x01\x02\xce\x01t\n\r\n\
    \x05\x04\r\x02\x02\x05\x12\x04\xcf\x01\x02\x08\n\r\n\x05\x04\r\x02\x02\
    \x01\x12\x04\xcf\x01\t\x18\n\r\n\x05\x04\r\x02\x02\x03\x12\x04\xcf\x01\
    \x1b\x1c\n\x0f\n\x05\x04\r\x02\x02\x08\x12\x06\xcf\x01\x1d\xd3\x01\x03\n\
    \x10\n\x08\x04\r\x02\x02\x08\xeb\xfb\x03\x12\x04\xd0\x01\x04E\n\x10\n\
    \x08\x04\r\x02\x02\x08\xe9\xfb\x03\x12\x04\xd1\x01\x04\"\n\x10\n\x08\x04\
    \r\x02\x02\x08\xee\xfb\x03\x12\x04\xd2\x01\x047\n\x0e\n\x04\x04\r\x02\
    \x03\x12\x06\xd4\x01\x02\xd5\x01h\n\x0f\n\x05\x04\r\x02\x03\x04\x12\x06\
    \xd4\x01\x02\xd3\x01\x04\n\r\n\x05\x04\r\x02\x03\x05\x12\x04\xd4\x01\x02\
    \x08\n\r\n\x05\x04\r\x02\x03\x01\x12\x04\xd4\x01\t\x13\n\r\n\x05\x04\r\
    \x02\x03\x03\x12\x04\xd4\x01\x16\x17\n\r\n\x05\x04\r\x02\x03\x08\x12\x04\
    \xd5\x01\x06g\n\x10\n\x08\x04\r\x02\x03\x08\xeb\xfb\x03\x12\x04\xd5\x01\
    \x07H\n\x10\n\x08\x04\r\x02\x03\x08\xe9\xfb\x03\x12\x04\xd5\x01Jf\n\xa9\
    \x01\n\x02\x04\x0e\x12\x06\xda\x01\0\xe3\x01\x01\x1a\x9a\x01\x20Redelega\
    tion\x20contains\x20the\x20list\x20of\x20a\x20particular\x20delegator's\
    \x20redelegating\x20bonds\n\x20from\x20a\x20particular\x20source\x20vali\
    dator\x20to\x20a\x20particular\x20destination\x20validator.\n\n\x0b\n\
    \x03\x04\x0e\x01\x12\x04\xda\x01\x08\x14\n\x0b\n\x03\x04\x0e\x07\x12\x04\
    \xdb\x01\x02.\n\x0e\n\x06\x04\x0e\x07\x8d\xf4\x03\x12\x04\xdb\x01\x02.\n\
    \x0b\n\x03\x04\x0e\x07\x12\x04\xdc\x01\x02.\n\x0e\n\x06\x04\x0e\x07\x81\
    \xf4\x03\x12\x04\xdc\x01\x02.\n\x0b\n\x03\x04\x0e\x07\x12\x04\xdd\x01\
    \x02.\n\x0e\n\x06\x04\x0e\x07\x83\xf4\x03\x12\x04\xdd\x01\x02.\n\x0c\n\
    \x04\x04\x0e\x02\0\x12\x04\xdf\x01\x02m\n\x0f\n\x05\x04\x0e\x02\0\x04\
    \x12\x06\xdf\x01\x02\xdd\x01.\n\r\n\x05\x04\x0e\x02\0\x05\x12\x04\xdf\
    \x01\x02\x08\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\xdf\x01\x1d.\n\r\n\x05\
    \x04\x0e\x02\0\x03\x12\x04\xdf\x0156\n\r\n\x05\x04\x0e\x02\0\x08\x12\x04\
    \xdf\x017l\n\x10\n\x08\x04\x0e\x02\0\x08\xee\xfb\x03\x12\x04\xdf\x018k\n\
    \x0c\n\x04\x04\x0e\x02\x01\x12\x04\xe0\x01\x02q\n\x0f\n\x05\x04\x0e\x02\
    \x01\x04\x12\x06\xe0\x01\x02\xdf\x01m\n\r\n\x05\x04\x0e\x02\x01\x05\x12\
    \x04\xe0\x01\x02\x08\n\r\n\x05\x04\x0e\x02\x01\x01\x12\x04\xe0\x01\x1d2\
    \n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\xe0\x0156\n\r\n\x05\x04\x0e\x02\
    \x01\x08\x12\x04\xe0\x017p\n\x10\n\x08\x04\x0e\x02\x01\x08\xee\xfb\x03\
    \x12\x04\xe0\x018o\n\x0c\n\x04\x04\x0e\x02\x02\x12\x04\xe1\x01\x02q\n\
    \x0f\n\x05\x04\x0e\x02\x02\x04\x12\x06\xe1\x01\x02\xe0\x01q\n\r\n\x05\
    \x04\x0e\x02\x02\x05\x12\x04\xe1\x01\x02\x08\n\r\n\x05\x04\x0e\x02\x02\
    \x01\x12\x04\xe1\x01\x1d2\n\r\n\x05\x04\x0e\x02\x02\x03\x12\x04\xe1\x015\
    6\n\r\n\x05\x04\x0e\x02\x02\x08\x12\x04\xe1\x017p\n\x10\n\x08\x04\x0e\
    \x02\x02\x08\xee\xfb\x03\x12\x04\xe1\x018o\n$\n\x04\x04\x0e\x02\x03\x12\
    \x04\xe2\x01\x02V\"\x16\x20redelegation\x20entries\n\n\r\n\x05\x04\x0e\
    \x02\x03\x04\x12\x04\xe2\x01\x02\n\n\r\n\x05\x04\x0e\x02\x03\x06\x12\x04\
    \xe2\x01\x0b\x1c\n\r\n\x05\x04\x0e\x02\x03\x01\x12\x04\xe2\x01\x1d$\n\r\
    \n\x05\x04\x0e\x02\x03\x03\x12\x04\xe2\x0156\n\r\n\x05\x04\x0e\x02\x03\
    \x08\x12\x04\xe2\x017U\n\x10\n\x08\x04\x0e\x02\x03\x08\xe9\xfb\x03\x12\
    \x04\xe2\x018T\nE\n\x02\x04\x0f\x12\x06\xe6\x01\0\xf0\x01\x01\x1a7\x20Pa\
    rams\x20defines\x20the\x20parameters\x20for\x20the\x20staking\x20module.\
    \n\n\x0b\n\x03\x04\x0f\x01\x12\x04\xe6\x01\x08\x0e\n\x0b\n\x03\x04\x0f\
    \x07\x12\x04\xe7\x01\x02-\n\x0e\n\x06\x04\x0f\x07\x8d\xf4\x03\x12\x04\
    \xe7\x01\x02-\n\x0b\n\x03\x04\x0f\x07\x12\x04\xe8\x01\x02.\n\x0e\n\x06\
    \x04\x0f\x07\x83\xf4\x03\x12\x04\xe8\x01\x02.\n\x0e\n\x04\x04\x0f\x02\0\
    \x12\x06\xea\x01\x02\xeb\x01w\n\x0f\n\x05\x04\x0f\x02\0\x04\x12\x06\xea\
    \x01\x02\xe8\x01.\n\r\n\x05\x04\x0f\x02\0\x06\x12\x04\xea\x01\x02\x1a\n\
    \r\n\x05\x04\x0f\x02\0\x01\x12\x04\xea\x01\x1b)\n\r\n\x05\x04\x0f\x02\0\
    \x03\x12\x04\xea\x01,-\n\r\n\x05\x04\x0f\x02\0\x08\x12\x04\xeb\x01\x06v\
    \n\x10\n\x08\x04\x0f\x02\0\x08\xe9\xfb\x03\x12\x04\xeb\x01\x07#\n\x10\n\
    \x08\x04\x0f\x02\0\x08\xf3\xfb\x03\x12\x04\xeb\x01%C\n\x10\n\x08\x04\x0f\
    \x02\0\x08\xee\xfb\x03\x12\x04\xeb\x01Eu\n\x0c\n\x04\x04\x0f\x02\x01\x12\
    \x04\xec\x01\x02S\n\x0f\n\x05\x04\x0f\x02\x01\x04\x12\x06\xec\x01\x02\
    \xeb\x01w\n\r\n\x05\x04\x0f\x02\x01\x05\x12\x04\xec\x01\x02\x08\n\r\n\
    \x05\x04\x0f\x02\x01\x01\x12\x04\xec\x01\t\x17\n\r\n\x05\x04\x0f\x02\x01\
    \x03\x12\x04\xec\x01\x1e\x1f\n\r\n\x05\x04\x0f\x02\x01\x08\x12\x04\xec\
    \x01\x20R\n\x10\n\x08\x04\x0f\x02\x01\x08\xee\xfb\x03\x12\x04\xec\x01!Q\
    \n\x0c\n\x04\x04\x0f\x02\x02\x12\x04\xed\x01\x02P\n\x0f\n\x05\x04\x0f\
    \x02\x02\x04\x12\x06\xed\x01\x02\xec\x01S\n\r\n\x05\x04\x0f\x02\x02\x05\
    \x12\x04\xed\x01\x02\x08\n\r\n\x05\x04\x0f\x02\x02\x01\x12\x04\xed\x01\t\
    \x14\n\r\n\x05\x04\x0f\x02\x02\x03\x12\x04\xed\x01\x1e\x1f\n\r\n\x05\x04\
    \x0f\x02\x02\x08\x12\x04\xed\x01\x20O\n\x10\n\x08\x04\x0f\x02\x02\x08\
    \xee\xfb\x03\x12\x04\xed\x01!N\n\x0c\n\x04\x04\x0f\x02\x03\x12\x04\xee\
    \x01\x02W\n\x0f\n\x05\x04\x0f\x02\x03\x04\x12\x06\xee\x01\x02\xed\x01P\n\
    \r\n\x05\x04\x0f\x02\x03\x05\x12\x04\xee\x01\x02\x08\n\r\n\x05\x04\x0f\
    \x02\x03\x01\x12\x04\xee\x01\t\x1b\n\r\n\x05\x04\x0f\x02\x03\x03\x12\x04\
    \xee\x01\x1e\x1f\n\r\n\x05\x04\x0f\x02\x03\x08\x12\x04\xee\x01\x20V\n\
    \x10\n\x08\x04\x0f\x02\x03\x08\xee\xfb\x03\x12\x04\xee\x01!U\n\x0c\n\x04\
    \x04\x0f\x02\x04\x12\x04\xef\x01\x02O\n\x0f\n\x05\x04\x0f\x02\x04\x04\
    \x12\x06\xef\x01\x02\xee\x01W\n\r\n\x05\x04\x0f\x02\x04\x05\x12\x04\xef\
    \x01\x02\x08\n\r\n\x05\x04\x0f\x02\x04\x01\x12\x04\xef\x01\t\x13\n\r\n\
    \x05\x04\x0f\x02\x04\x03\x12\x04\xef\x01\x1e\x1f\n\r\n\x05\x04\x0f\x02\
    \x04\x08\x12\x04\xef\x01\x20N\n\x10\n\x08\x04\x0f\x02\x04\x08\xee\xfb\
    \x03\x12\x04\xef\x01!M\n\xa5\x01\n\x02\x04\x10\x12\x06\xf4\x01\0\xfb\x01\
    \x01\x1a\x96\x01\x20DelegationResponse\x20is\x20equivalent\x20to\x20Dele\
    gation\x20except\x20that\x20it\x20contains\x20a\n\x20balance\x20in\x20ad\
    dition\x20to\x20shares\x20which\x20is\x20more\x20suitable\x20for\x20clie\
    nt\x20responses.\n\n\x0b\n\x03\x04\x10\x01\x12\x04\xf4\x01\x08\x1a\n\x0b\
    \n\x03\x04\x10\x07\x12\x04\xf5\x01\x02.\n\x0e\n\x06\x04\x10\x07\x8d\xf4\
    \x03\x12\x04\xf5\x01\x02.\n\x0b\n\x03\x04\x10\x07\x12\x04\xf6\x01\x02.\n\
    \x0e\n\x06\x04\x10\x07\x83\xf4\x03\x12\x04\xf6\x01\x02.\n\x0c\n\x04\x04\
    \x10\x02\0\x12\x04\xf8\x01\x02;\n\x0f\n\x05\x04\x10\x02\0\x04\x12\x06\
    \xf8\x01\x02\xf6\x01.\n\r\n\x05\x04\x10\x02\0\x06\x12\x04\xf8\x01\x02\
    \x0c\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\xf8\x01\r\x17\n\r\n\x05\x04\x10\
    \x02\0\x03\x12\x04\xf8\x01\x1a\x1b\n\r\n\x05\x04\x10\x02\0\x08\x12\x04\
    \xf8\x01\x1c:\n\x10\n\x08\x04\x10\x02\0\x08\xe9\xfb\x03\x12\x04\xf8\x01\
    \x1d9\n\x0c\n\x04\x04\x10\x02\x01\x12\x04\xfa\x01\x02F\n\x0f\n\x05\x04\
    \x10\x02\x01\x04\x12\x06\xfa\x01\x02\xf8\x01;\n\r\n\x05\x04\x10\x02\x01\
    \x06\x12\x04\xfa\x01\x02\x1a\n\r\n\x05\x04\x10\x02\x01\x01\x12\x04\xfa\
    \x01\x1b\"\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\xfa\x01%&\n\r\n\x05\x04\
    \x10\x02\x01\x08\x12\x04\xfa\x01'E\n\x10\n\x08\x04\x10\x02\x01\x08\xe9\
    \xfb\x03\x12\x04\xfa\x01(D\n\xb6\x01\n\x02\x04\x11\x12\x06\x80\x02\0\x85\
    \x02\x01\x1a\xa7\x01\x20RedelegationEntryResponse\x20is\x20equivalent\
    \x20to\x20a\x20RedelegationEntry\x20except\x20that\x20it\n\x20contains\
    \x20a\x20balance\x20in\x20addition\x20to\x20shares\x20which\x20is\x20mor\
    e\x20suitable\x20for\x20client\n\x20responses.\n\n\x0b\n\x03\x04\x11\x01\
    \x12\x04\x80\x02\x08!\n\x0b\n\x03\x04\x11\x07\x12\x04\x81\x02\x02\"\n\
    \x0e\n\x06\x04\x11\x07\x8d\xf4\x03\x12\x04\x81\x02\x02\"\n\x0c\n\x04\x04\
    \x11\x02\0\x12\x04\x83\x02\x02J\n\x0f\n\x05\x04\x11\x02\0\x04\x12\x06\
    \x83\x02\x02\x81\x02\"\n\r\n\x05\x04\x11\x02\0\x06\x12\x04\x83\x02\x02\
    \x13\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\x83\x02\x14&\n\r\n\x05\x04\x11\
    \x02\0\x03\x12\x04\x83\x02)*\n\r\n\x05\x04\x11\x02\0\x08\x12\x04\x83\x02\
    +I\n\x10\n\x08\x04\x11\x02\0\x08\xe9\xfb\x03\x12\x04\x83\x02,H\n\x0c\n\
    \x04\x04\x11\x02\x01\x12\x04\x84\x02\x02w\n\x0f\n\x05\x04\x11\x02\x01\
    \x04\x12\x06\x84\x02\x02\x83\x02J\n\r\n\x05\x04\x11\x02\x01\x05\x12\x04\
    \x84\x02\x02\x08\n\r\n\x05\x04\x11\x02\x01\x01\x12\x04\x84\x02\t\x10\n\r\
    \n\x05\x04\x11\x02\x01\x03\x12\x04\x84\x02\x13\x14\n\r\n\x05\x04\x11\x02\
    \x01\x08\x12\x04\x84\x02\x15v\n\x10\n\x08\x04\x11\x02\x01\x08\xeb\xfb\
    \x03\x12\x04\x84\x02\x16W\n\x10\n\x08\x04\x11\x02\x01\x08\xe9\xfb\x03\
    \x12\x04\x84\x02Yu\n\xb4\x01\n\x02\x04\x12\x12\x06\x8a\x02\0\x8f\x02\x01\
    \x1a\xa5\x01\x20RedelegationResponse\x20is\x20equivalent\x20to\x20a\x20R\
    edelegation\x20except\x20that\x20its\x20entries\n\x20contain\x20a\x20bal\
    ance\x20in\x20addition\x20to\x20shares\x20which\x20is\x20more\x20suitabl\
    e\x20for\x20client\n\x20responses.\n\n\x0b\n\x03\x04\x12\x01\x12\x04\x8a\
    \x02\x08\x1c\n\x0b\n\x03\x04\x12\x07\x12\x04\x8b\x02\x02#\n\x0e\n\x06\
    \x04\x12\x07\x8d\xf4\x03\x12\x04\x8b\x02\x02#\n\x0c\n\x04\x04\x12\x02\0\
    \x12\x04\x8d\x02\x02U\n\x0f\n\x05\x04\x12\x02\0\x04\x12\x06\x8d\x02\x02\
    \x8b\x02#\n\r\n\x05\x04\x12\x02\0\x06\x12\x04\x8d\x02\x02\x0e\n\r\n\x05\
    \x04\x12\x02\0\x01\x12\x04\x8d\x02%1\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\
    \x8d\x0245\n\r\n\x05\x04\x12\x02\0\x08\x12\x04\x8d\x026T\n\x10\n\x08\x04\
    \x12\x02\0\x08\xe9\xfb\x03\x12\x04\x8d\x027S\n\x0c\n\x04\x04\x12\x02\x01\
    \x12\x04\x8e\x02\x02U\n\r\n\x05\x04\x12\x02\x01\x04\x12\x04\x8e\x02\x02\
    \n\n\r\n\x05\x04\x12\x02\x01\x06\x12\x04\x8e\x02\x0b$\n\r\n\x05\x04\x12\
    \x02\x01\x01\x12\x04\x8e\x02%,\n\r\n\x05\x04\x12\x02\x01\x03\x12\x04\x8e\
    \x0245\n\r\n\x05\x04\x12\x02\x01\x08\x12\x04\x8e\x026T\n\x10\n\x08\x04\
    \x12\x02\x01\x08\xe9\xfb\x03\x12\x04\x8e\x027S\ng\n\x02\x04\x13\x12\x06\
    \x93\x02\0\xa1\x02\x01\x1aY\x20Pool\x20is\x20used\x20for\x20tracking\x20\
    bonded\x20and\x20not-bonded\x20token\x20supply\x20of\x20the\x20bond\n\
    \x20denomination.\n\n\x0b\n\x03\x04\x13\x01\x12\x04\x93\x02\x08\x0c\n\
    \x0b\n\x03\x04\x13\x07\x12\x04\x94\x02\x02(\n\x0e\n\x06\x04\x13\x07\x8e\
    \xf4\x03\x12\x04\x94\x02\x02(\n\x0b\n\x03\x04\x13\x07\x12\x04\x95\x02\
    \x02(\n\x0e\n\x06\x04\x13\x07\x8d\xf4\x03\x12\x04\x95\x02\x02(\n\x0e\n\
    \x04\x04\x13\x02\0\x12\x06\x96\x02\x02\x9a\x02\x04\n\x0f\n\x05\x04\x13\
    \x02\0\x04\x12\x06\x96\x02\x02\x95\x02(\n\r\n\x05\x04\x13\x02\0\x05\x12\
    \x04\x96\x02\x02\x08\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\x96\x02\t\x1a\n\
    \r\n\x05\x04\x13\x02\0\x03\x12\x04\x96\x02#$\n\x0f\n\x05\x04\x13\x02\0\
    \x08\x12\x06\x96\x02%\x9a\x02\x03\n\x10\n\x08\x04\x13\x02\0\x08\xeb\xfb\
    \x03\x12\x04\x97\x02\x04E\n\x10\n\x08\x04\x13\x02\0\x08\xed\xfb\x03\x12\
    \x04\x98\x02\x040\n\x10\n\x08\x04\x13\x02\0\x08\xe9\xfb\x03\x12\x04\x99\
    \x02\x04\"\n\x0e\n\x04\x04\x13\x02\x01\x12\x06\x9b\x02\x02\xa0\x02\x04\n\
    \x0f\n\x05\x04\x13\x02\x01\x04\x12\x06\x9b\x02\x02\x9a\x02\x04\n\r\n\x05\
    \x04\x13\x02\x01\x05\x12\x04\x9b\x02\x02\x08\n\r\n\x05\x04\x13\x02\x01\
    \x01\x12\x04\x9b\x02\t\x16\n\r\n\x05\x04\x13\x02\x01\x03\x12\x04\x9b\x02\
    \x19\x1a\n\x0f\n\x05\x04\x13\x02\x01\x08\x12\x06\x9b\x02\x1b\xa0\x02\x03\
    \n\x10\n\x08\x04\x13\x02\x01\x08\xed\xfb\x03\x12\x04\x9c\x02\x04,\n\x10\
    \n\x08\x04\x13\x02\x01\x08\xeb\xfb\x03\x12\x04\x9d\x02\x04E\n\x10\n\x08\
    \x04\x13\x02\x01\x08\xe9\xfb\x03\x12\x04\x9e\x02\x04\"\n\x10\n\x08\x04\
    \x13\x02\x01\x08\xee\xfb\x03\x12\x04\x9f\x02\x045b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
