// This file is generated by rust-protobuf 2.20.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `confio/proofs.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_20_0;

#[derive(PartialEq,Clone,Default)]
pub struct ExistenceProof {
    // message fields
    pub key: ::std::vec::Vec<u8>,
    pub value: ::std::vec::Vec<u8>,
    pub leaf: ::protobuf::SingularPtrField<LeafOp>,
    pub path: ::protobuf::RepeatedField<InnerOp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExistenceProof {
    fn default() -> &'a ExistenceProof {
        <ExistenceProof as ::protobuf::Message>::default_instance()
    }
}

impl ExistenceProof {
    pub fn new() -> ExistenceProof {
        ::std::default::Default::default()
    }

    // bytes key = 1;


    pub fn get_key(&self) -> &[u8] {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.key, ::std::vec::Vec::new())
    }

    // bytes value = 2;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }

    // .ics23.LeafOp leaf = 3;


    pub fn get_leaf(&self) -> &LeafOp {
        self.leaf.as_ref().unwrap_or_else(|| <LeafOp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_leaf(&mut self) {
        self.leaf.clear();
    }

    pub fn has_leaf(&self) -> bool {
        self.leaf.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaf(&mut self, v: LeafOp) {
        self.leaf = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_leaf(&mut self) -> &mut LeafOp {
        if self.leaf.is_none() {
            self.leaf.set_default();
        }
        self.leaf.as_mut().unwrap()
    }

    // Take field
    pub fn take_leaf(&mut self) -> LeafOp {
        self.leaf.take().unwrap_or_else(|| LeafOp::new())
    }

    // repeated .ics23.InnerOp path = 4;


    pub fn get_path(&self) -> &[InnerOp] {
        &self.path
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::protobuf::RepeatedField<InnerOp>) {
        self.path = v;
    }

    // Mutable pointer to the field.
    pub fn mut_path(&mut self) -> &mut ::protobuf::RepeatedField<InnerOp> {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::protobuf::RepeatedField<InnerOp> {
        ::std::mem::replace(&mut self.path, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ExistenceProof {
    fn is_initialized(&self) -> bool {
        for v in &self.leaf {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.path {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.leaf)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.value);
        }
        if let Some(ref v) = self.leaf.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.path {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_bytes(1, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(2, &self.value)?;
        }
        if let Some(ref v) = self.leaf.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.path {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExistenceProof {
        ExistenceProof::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "key",
                |m: &ExistenceProof| { &m.key },
                |m: &mut ExistenceProof| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "value",
                |m: &ExistenceProof| { &m.value },
                |m: &mut ExistenceProof| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LeafOp>>(
                "leaf",
                |m: &ExistenceProof| { &m.leaf },
                |m: &mut ExistenceProof| { &mut m.leaf },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InnerOp>>(
                "path",
                |m: &ExistenceProof| { &m.path },
                |m: &mut ExistenceProof| { &mut m.path },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExistenceProof>(
                "ExistenceProof",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExistenceProof {
        static instance: ::protobuf::rt::LazyV2<ExistenceProof> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExistenceProof::new)
    }
}

impl ::protobuf::Clear for ExistenceProof {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.leaf.clear();
        self.path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExistenceProof {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExistenceProof {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NonExistenceProof {
    // message fields
    pub key: ::std::vec::Vec<u8>,
    pub left: ::protobuf::SingularPtrField<ExistenceProof>,
    pub right: ::protobuf::SingularPtrField<ExistenceProof>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NonExistenceProof {
    fn default() -> &'a NonExistenceProof {
        <NonExistenceProof as ::protobuf::Message>::default_instance()
    }
}

impl NonExistenceProof {
    pub fn new() -> NonExistenceProof {
        ::std::default::Default::default()
    }

    // bytes key = 1;


    pub fn get_key(&self) -> &[u8] {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.key, ::std::vec::Vec::new())
    }

    // .ics23.ExistenceProof left = 2;


    pub fn get_left(&self) -> &ExistenceProof {
        self.left.as_ref().unwrap_or_else(|| <ExistenceProof as ::protobuf::Message>::default_instance())
    }
    pub fn clear_left(&mut self) {
        self.left.clear();
    }

    pub fn has_left(&self) -> bool {
        self.left.is_some()
    }

    // Param is passed by value, moved
    pub fn set_left(&mut self, v: ExistenceProof) {
        self.left = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_left(&mut self) -> &mut ExistenceProof {
        if self.left.is_none() {
            self.left.set_default();
        }
        self.left.as_mut().unwrap()
    }

    // Take field
    pub fn take_left(&mut self) -> ExistenceProof {
        self.left.take().unwrap_or_else(|| ExistenceProof::new())
    }

    // .ics23.ExistenceProof right = 3;


    pub fn get_right(&self) -> &ExistenceProof {
        self.right.as_ref().unwrap_or_else(|| <ExistenceProof as ::protobuf::Message>::default_instance())
    }
    pub fn clear_right(&mut self) {
        self.right.clear();
    }

    pub fn has_right(&self) -> bool {
        self.right.is_some()
    }

    // Param is passed by value, moved
    pub fn set_right(&mut self, v: ExistenceProof) {
        self.right = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_right(&mut self) -> &mut ExistenceProof {
        if self.right.is_none() {
            self.right.set_default();
        }
        self.right.as_mut().unwrap()
    }

    // Take field
    pub fn take_right(&mut self) -> ExistenceProof {
        self.right.take().unwrap_or_else(|| ExistenceProof::new())
    }
}

impl ::protobuf::Message for NonExistenceProof {
    fn is_initialized(&self) -> bool {
        for v in &self.left {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.right {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.left)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.right)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.key);
        }
        if let Some(ref v) = self.left.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.right.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_bytes(1, &self.key)?;
        }
        if let Some(ref v) = self.left.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.right.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NonExistenceProof {
        NonExistenceProof::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "key",
                |m: &NonExistenceProof| { &m.key },
                |m: &mut NonExistenceProof| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExistenceProof>>(
                "left",
                |m: &NonExistenceProof| { &m.left },
                |m: &mut NonExistenceProof| { &mut m.left },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExistenceProof>>(
                "right",
                |m: &NonExistenceProof| { &m.right },
                |m: &mut NonExistenceProof| { &mut m.right },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NonExistenceProof>(
                "NonExistenceProof",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NonExistenceProof {
        static instance: ::protobuf::rt::LazyV2<NonExistenceProof> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NonExistenceProof::new)
    }
}

impl ::protobuf::Clear for NonExistenceProof {
    fn clear(&mut self) {
        self.key.clear();
        self.left.clear();
        self.right.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NonExistenceProof {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NonExistenceProof {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommitmentProof {
    // message oneof groups
    pub proof: ::std::option::Option<CommitmentProof_oneof_proof>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommitmentProof {
    fn default() -> &'a CommitmentProof {
        <CommitmentProof as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum CommitmentProof_oneof_proof {
    exist(ExistenceProof),
    nonexist(NonExistenceProof),
    batch(BatchProof),
    compressed(CompressedBatchProof),
}

impl CommitmentProof {
    pub fn new() -> CommitmentProof {
        ::std::default::Default::default()
    }

    // .ics23.ExistenceProof exist = 1;


    pub fn get_exist(&self) -> &ExistenceProof {
        match self.proof {
            ::std::option::Option::Some(CommitmentProof_oneof_proof::exist(ref v)) => v,
            _ => <ExistenceProof as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_exist(&mut self) {
        self.proof = ::std::option::Option::None;
    }

    pub fn has_exist(&self) -> bool {
        match self.proof {
            ::std::option::Option::Some(CommitmentProof_oneof_proof::exist(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_exist(&mut self, v: ExistenceProof) {
        self.proof = ::std::option::Option::Some(CommitmentProof_oneof_proof::exist(v))
    }

    // Mutable pointer to the field.
    pub fn mut_exist(&mut self) -> &mut ExistenceProof {
        if let ::std::option::Option::Some(CommitmentProof_oneof_proof::exist(_)) = self.proof {
        } else {
            self.proof = ::std::option::Option::Some(CommitmentProof_oneof_proof::exist(ExistenceProof::new()));
        }
        match self.proof {
            ::std::option::Option::Some(CommitmentProof_oneof_proof::exist(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_exist(&mut self) -> ExistenceProof {
        if self.has_exist() {
            match self.proof.take() {
                ::std::option::Option::Some(CommitmentProof_oneof_proof::exist(v)) => v,
                _ => panic!(),
            }
        } else {
            ExistenceProof::new()
        }
    }

    // .ics23.NonExistenceProof nonexist = 2;


    pub fn get_nonexist(&self) -> &NonExistenceProof {
        match self.proof {
            ::std::option::Option::Some(CommitmentProof_oneof_proof::nonexist(ref v)) => v,
            _ => <NonExistenceProof as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_nonexist(&mut self) {
        self.proof = ::std::option::Option::None;
    }

    pub fn has_nonexist(&self) -> bool {
        match self.proof {
            ::std::option::Option::Some(CommitmentProof_oneof_proof::nonexist(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_nonexist(&mut self, v: NonExistenceProof) {
        self.proof = ::std::option::Option::Some(CommitmentProof_oneof_proof::nonexist(v))
    }

    // Mutable pointer to the field.
    pub fn mut_nonexist(&mut self) -> &mut NonExistenceProof {
        if let ::std::option::Option::Some(CommitmentProof_oneof_proof::nonexist(_)) = self.proof {
        } else {
            self.proof = ::std::option::Option::Some(CommitmentProof_oneof_proof::nonexist(NonExistenceProof::new()));
        }
        match self.proof {
            ::std::option::Option::Some(CommitmentProof_oneof_proof::nonexist(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_nonexist(&mut self) -> NonExistenceProof {
        if self.has_nonexist() {
            match self.proof.take() {
                ::std::option::Option::Some(CommitmentProof_oneof_proof::nonexist(v)) => v,
                _ => panic!(),
            }
        } else {
            NonExistenceProof::new()
        }
    }

    // .ics23.BatchProof batch = 3;


    pub fn get_batch(&self) -> &BatchProof {
        match self.proof {
            ::std::option::Option::Some(CommitmentProof_oneof_proof::batch(ref v)) => v,
            _ => <BatchProof as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_batch(&mut self) {
        self.proof = ::std::option::Option::None;
    }

    pub fn has_batch(&self) -> bool {
        match self.proof {
            ::std::option::Option::Some(CommitmentProof_oneof_proof::batch(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_batch(&mut self, v: BatchProof) {
        self.proof = ::std::option::Option::Some(CommitmentProof_oneof_proof::batch(v))
    }

    // Mutable pointer to the field.
    pub fn mut_batch(&mut self) -> &mut BatchProof {
        if let ::std::option::Option::Some(CommitmentProof_oneof_proof::batch(_)) = self.proof {
        } else {
            self.proof = ::std::option::Option::Some(CommitmentProof_oneof_proof::batch(BatchProof::new()));
        }
        match self.proof {
            ::std::option::Option::Some(CommitmentProof_oneof_proof::batch(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_batch(&mut self) -> BatchProof {
        if self.has_batch() {
            match self.proof.take() {
                ::std::option::Option::Some(CommitmentProof_oneof_proof::batch(v)) => v,
                _ => panic!(),
            }
        } else {
            BatchProof::new()
        }
    }

    // .ics23.CompressedBatchProof compressed = 4;


    pub fn get_compressed(&self) -> &CompressedBatchProof {
        match self.proof {
            ::std::option::Option::Some(CommitmentProof_oneof_proof::compressed(ref v)) => v,
            _ => <CompressedBatchProof as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_compressed(&mut self) {
        self.proof = ::std::option::Option::None;
    }

    pub fn has_compressed(&self) -> bool {
        match self.proof {
            ::std::option::Option::Some(CommitmentProof_oneof_proof::compressed(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_compressed(&mut self, v: CompressedBatchProof) {
        self.proof = ::std::option::Option::Some(CommitmentProof_oneof_proof::compressed(v))
    }

    // Mutable pointer to the field.
    pub fn mut_compressed(&mut self) -> &mut CompressedBatchProof {
        if let ::std::option::Option::Some(CommitmentProof_oneof_proof::compressed(_)) = self.proof {
        } else {
            self.proof = ::std::option::Option::Some(CommitmentProof_oneof_proof::compressed(CompressedBatchProof::new()));
        }
        match self.proof {
            ::std::option::Option::Some(CommitmentProof_oneof_proof::compressed(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_compressed(&mut self) -> CompressedBatchProof {
        if self.has_compressed() {
            match self.proof.take() {
                ::std::option::Option::Some(CommitmentProof_oneof_proof::compressed(v)) => v,
                _ => panic!(),
            }
        } else {
            CompressedBatchProof::new()
        }
    }
}

impl ::protobuf::Message for CommitmentProof {
    fn is_initialized(&self) -> bool {
        if let Some(CommitmentProof_oneof_proof::exist(ref v)) = self.proof {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CommitmentProof_oneof_proof::nonexist(ref v)) = self.proof {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CommitmentProof_oneof_proof::batch(ref v)) = self.proof {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CommitmentProof_oneof_proof::compressed(ref v)) = self.proof {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.proof = ::std::option::Option::Some(CommitmentProof_oneof_proof::exist(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.proof = ::std::option::Option::Some(CommitmentProof_oneof_proof::nonexist(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.proof = ::std::option::Option::Some(CommitmentProof_oneof_proof::batch(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.proof = ::std::option::Option::Some(CommitmentProof_oneof_proof::compressed(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.proof {
            match v {
                &CommitmentProof_oneof_proof::exist(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CommitmentProof_oneof_proof::nonexist(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CommitmentProof_oneof_proof::batch(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CommitmentProof_oneof_proof::compressed(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.proof {
            match v {
                &CommitmentProof_oneof_proof::exist(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CommitmentProof_oneof_proof::nonexist(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CommitmentProof_oneof_proof::batch(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CommitmentProof_oneof_proof::compressed(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommitmentProof {
        CommitmentProof::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ExistenceProof>(
                "exist",
                CommitmentProof::has_exist,
                CommitmentProof::get_exist,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, NonExistenceProof>(
                "nonexist",
                CommitmentProof::has_nonexist,
                CommitmentProof::get_nonexist,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, BatchProof>(
                "batch",
                CommitmentProof::has_batch,
                CommitmentProof::get_batch,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CompressedBatchProof>(
                "compressed",
                CommitmentProof::has_compressed,
                CommitmentProof::get_compressed,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CommitmentProof>(
                "CommitmentProof",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CommitmentProof {
        static instance: ::protobuf::rt::LazyV2<CommitmentProof> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommitmentProof::new)
    }
}

impl ::protobuf::Clear for CommitmentProof {
    fn clear(&mut self) {
        self.proof = ::std::option::Option::None;
        self.proof = ::std::option::Option::None;
        self.proof = ::std::option::Option::None;
        self.proof = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommitmentProof {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommitmentProof {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LeafOp {
    // message fields
    pub hash: HashOp,
    pub prehash_key: HashOp,
    pub prehash_value: HashOp,
    pub length: LengthOp,
    pub prefix: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LeafOp {
    fn default() -> &'a LeafOp {
        <LeafOp as ::protobuf::Message>::default_instance()
    }
}

impl LeafOp {
    pub fn new() -> LeafOp {
        ::std::default::Default::default()
    }

    // .ics23.HashOp hash = 1;


    pub fn get_hash(&self) -> HashOp {
        self.hash
    }
    pub fn clear_hash(&mut self) {
        self.hash = HashOp::NO_HASH;
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: HashOp) {
        self.hash = v;
    }

    // .ics23.HashOp prehash_key = 2;


    pub fn get_prehash_key(&self) -> HashOp {
        self.prehash_key
    }
    pub fn clear_prehash_key(&mut self) {
        self.prehash_key = HashOp::NO_HASH;
    }

    // Param is passed by value, moved
    pub fn set_prehash_key(&mut self, v: HashOp) {
        self.prehash_key = v;
    }

    // .ics23.HashOp prehash_value = 3;


    pub fn get_prehash_value(&self) -> HashOp {
        self.prehash_value
    }
    pub fn clear_prehash_value(&mut self) {
        self.prehash_value = HashOp::NO_HASH;
    }

    // Param is passed by value, moved
    pub fn set_prehash_value(&mut self, v: HashOp) {
        self.prehash_value = v;
    }

    // .ics23.LengthOp length = 4;


    pub fn get_length(&self) -> LengthOp {
        self.length
    }
    pub fn clear_length(&mut self) {
        self.length = LengthOp::NO_PREFIX;
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: LengthOp) {
        self.length = v;
    }

    // bytes prefix = 5;


    pub fn get_prefix(&self) -> &[u8] {
        &self.prefix
    }
    pub fn clear_prefix(&mut self) {
        self.prefix.clear();
    }

    // Param is passed by value, moved
    pub fn set_prefix(&mut self, v: ::std::vec::Vec<u8>) {
        self.prefix = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prefix(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.prefix
    }

    // Take field
    pub fn take_prefix(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.prefix, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for LeafOp {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.hash, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.prehash_key, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.prehash_value, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.length, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.prefix)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.hash != HashOp::NO_HASH {
            my_size += ::protobuf::rt::enum_size(1, self.hash);
        }
        if self.prehash_key != HashOp::NO_HASH {
            my_size += ::protobuf::rt::enum_size(2, self.prehash_key);
        }
        if self.prehash_value != HashOp::NO_HASH {
            my_size += ::protobuf::rt::enum_size(3, self.prehash_value);
        }
        if self.length != LengthOp::NO_PREFIX {
            my_size += ::protobuf::rt::enum_size(4, self.length);
        }
        if !self.prefix.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.prefix);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.hash != HashOp::NO_HASH {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.hash))?;
        }
        if self.prehash_key != HashOp::NO_HASH {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.prehash_key))?;
        }
        if self.prehash_value != HashOp::NO_HASH {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.prehash_value))?;
        }
        if self.length != LengthOp::NO_PREFIX {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.length))?;
        }
        if !self.prefix.is_empty() {
            os.write_bytes(5, &self.prefix)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LeafOp {
        LeafOp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<HashOp>>(
                "hash",
                |m: &LeafOp| { &m.hash },
                |m: &mut LeafOp| { &mut m.hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<HashOp>>(
                "prehash_key",
                |m: &LeafOp| { &m.prehash_key },
                |m: &mut LeafOp| { &mut m.prehash_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<HashOp>>(
                "prehash_value",
                |m: &LeafOp| { &m.prehash_value },
                |m: &mut LeafOp| { &mut m.prehash_value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<LengthOp>>(
                "length",
                |m: &LeafOp| { &m.length },
                |m: &mut LeafOp| { &mut m.length },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "prefix",
                |m: &LeafOp| { &m.prefix },
                |m: &mut LeafOp| { &mut m.prefix },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LeafOp>(
                "LeafOp",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LeafOp {
        static instance: ::protobuf::rt::LazyV2<LeafOp> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LeafOp::new)
    }
}

impl ::protobuf::Clear for LeafOp {
    fn clear(&mut self) {
        self.hash = HashOp::NO_HASH;
        self.prehash_key = HashOp::NO_HASH;
        self.prehash_value = HashOp::NO_HASH;
        self.length = LengthOp::NO_PREFIX;
        self.prefix.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LeafOp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LeafOp {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct InnerOp {
    // message fields
    pub hash: HashOp,
    pub prefix: ::std::vec::Vec<u8>,
    pub suffix: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InnerOp {
    fn default() -> &'a InnerOp {
        <InnerOp as ::protobuf::Message>::default_instance()
    }
}

impl InnerOp {
    pub fn new() -> InnerOp {
        ::std::default::Default::default()
    }

    // .ics23.HashOp hash = 1;


    pub fn get_hash(&self) -> HashOp {
        self.hash
    }
    pub fn clear_hash(&mut self) {
        self.hash = HashOp::NO_HASH;
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: HashOp) {
        self.hash = v;
    }

    // bytes prefix = 2;


    pub fn get_prefix(&self) -> &[u8] {
        &self.prefix
    }
    pub fn clear_prefix(&mut self) {
        self.prefix.clear();
    }

    // Param is passed by value, moved
    pub fn set_prefix(&mut self, v: ::std::vec::Vec<u8>) {
        self.prefix = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prefix(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.prefix
    }

    // Take field
    pub fn take_prefix(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.prefix, ::std::vec::Vec::new())
    }

    // bytes suffix = 3;


    pub fn get_suffix(&self) -> &[u8] {
        &self.suffix
    }
    pub fn clear_suffix(&mut self) {
        self.suffix.clear();
    }

    // Param is passed by value, moved
    pub fn set_suffix(&mut self, v: ::std::vec::Vec<u8>) {
        self.suffix = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_suffix(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.suffix
    }

    // Take field
    pub fn take_suffix(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.suffix, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for InnerOp {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.hash, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.prefix)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.suffix)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.hash != HashOp::NO_HASH {
            my_size += ::protobuf::rt::enum_size(1, self.hash);
        }
        if !self.prefix.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.prefix);
        }
        if !self.suffix.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.suffix);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.hash != HashOp::NO_HASH {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.hash))?;
        }
        if !self.prefix.is_empty() {
            os.write_bytes(2, &self.prefix)?;
        }
        if !self.suffix.is_empty() {
            os.write_bytes(3, &self.suffix)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InnerOp {
        InnerOp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<HashOp>>(
                "hash",
                |m: &InnerOp| { &m.hash },
                |m: &mut InnerOp| { &mut m.hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "prefix",
                |m: &InnerOp| { &m.prefix },
                |m: &mut InnerOp| { &mut m.prefix },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "suffix",
                |m: &InnerOp| { &m.suffix },
                |m: &mut InnerOp| { &mut m.suffix },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InnerOp>(
                "InnerOp",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InnerOp {
        static instance: ::protobuf::rt::LazyV2<InnerOp> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InnerOp::new)
    }
}

impl ::protobuf::Clear for InnerOp {
    fn clear(&mut self) {
        self.hash = HashOp::NO_HASH;
        self.prefix.clear();
        self.suffix.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InnerOp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InnerOp {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ProofSpec {
    // message fields
    pub leaf_spec: ::protobuf::SingularPtrField<LeafOp>,
    pub inner_spec: ::protobuf::SingularPtrField<InnerSpec>,
    pub max_depth: i32,
    pub min_depth: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProofSpec {
    fn default() -> &'a ProofSpec {
        <ProofSpec as ::protobuf::Message>::default_instance()
    }
}

impl ProofSpec {
    pub fn new() -> ProofSpec {
        ::std::default::Default::default()
    }

    // .ics23.LeafOp leaf_spec = 1;


    pub fn get_leaf_spec(&self) -> &LeafOp {
        self.leaf_spec.as_ref().unwrap_or_else(|| <LeafOp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_leaf_spec(&mut self) {
        self.leaf_spec.clear();
    }

    pub fn has_leaf_spec(&self) -> bool {
        self.leaf_spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaf_spec(&mut self, v: LeafOp) {
        self.leaf_spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_leaf_spec(&mut self) -> &mut LeafOp {
        if self.leaf_spec.is_none() {
            self.leaf_spec.set_default();
        }
        self.leaf_spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_leaf_spec(&mut self) -> LeafOp {
        self.leaf_spec.take().unwrap_or_else(|| LeafOp::new())
    }

    // .ics23.InnerSpec inner_spec = 2;


    pub fn get_inner_spec(&self) -> &InnerSpec {
        self.inner_spec.as_ref().unwrap_or_else(|| <InnerSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_inner_spec(&mut self) {
        self.inner_spec.clear();
    }

    pub fn has_inner_spec(&self) -> bool {
        self.inner_spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inner_spec(&mut self, v: InnerSpec) {
        self.inner_spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_inner_spec(&mut self) -> &mut InnerSpec {
        if self.inner_spec.is_none() {
            self.inner_spec.set_default();
        }
        self.inner_spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_inner_spec(&mut self) -> InnerSpec {
        self.inner_spec.take().unwrap_or_else(|| InnerSpec::new())
    }

    // int32 max_depth = 3;


    pub fn get_max_depth(&self) -> i32 {
        self.max_depth
    }
    pub fn clear_max_depth(&mut self) {
        self.max_depth = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_depth(&mut self, v: i32) {
        self.max_depth = v;
    }

    // int32 min_depth = 4;


    pub fn get_min_depth(&self) -> i32 {
        self.min_depth
    }
    pub fn clear_min_depth(&mut self) {
        self.min_depth = 0;
    }

    // Param is passed by value, moved
    pub fn set_min_depth(&mut self, v: i32) {
        self.min_depth = v;
    }
}

impl ::protobuf::Message for ProofSpec {
    fn is_initialized(&self) -> bool {
        for v in &self.leaf_spec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.inner_spec {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.leaf_spec)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.inner_spec)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_depth = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.min_depth = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.leaf_spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.inner_spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.max_depth != 0 {
            my_size += ::protobuf::rt::value_size(3, self.max_depth, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.min_depth != 0 {
            my_size += ::protobuf::rt::value_size(4, self.min_depth, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.leaf_spec.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.inner_spec.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.max_depth != 0 {
            os.write_int32(3, self.max_depth)?;
        }
        if self.min_depth != 0 {
            os.write_int32(4, self.min_depth)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProofSpec {
        ProofSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LeafOp>>(
                "leaf_spec",
                |m: &ProofSpec| { &m.leaf_spec },
                |m: &mut ProofSpec| { &mut m.leaf_spec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InnerSpec>>(
                "inner_spec",
                |m: &ProofSpec| { &m.inner_spec },
                |m: &mut ProofSpec| { &mut m.inner_spec },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "max_depth",
                |m: &ProofSpec| { &m.max_depth },
                |m: &mut ProofSpec| { &mut m.max_depth },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "min_depth",
                |m: &ProofSpec| { &m.min_depth },
                |m: &mut ProofSpec| { &mut m.min_depth },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ProofSpec>(
                "ProofSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ProofSpec {
        static instance: ::protobuf::rt::LazyV2<ProofSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ProofSpec::new)
    }
}

impl ::protobuf::Clear for ProofSpec {
    fn clear(&mut self) {
        self.leaf_spec.clear();
        self.inner_spec.clear();
        self.max_depth = 0;
        self.min_depth = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProofSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProofSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct InnerSpec {
    // message fields
    pub child_order: ::std::vec::Vec<i32>,
    pub child_size: i32,
    pub min_prefix_length: i32,
    pub max_prefix_length: i32,
    pub empty_child: ::std::vec::Vec<u8>,
    pub hash: HashOp,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InnerSpec {
    fn default() -> &'a InnerSpec {
        <InnerSpec as ::protobuf::Message>::default_instance()
    }
}

impl InnerSpec {
    pub fn new() -> InnerSpec {
        ::std::default::Default::default()
    }

    // repeated int32 child_order = 1;


    pub fn get_child_order(&self) -> &[i32] {
        &self.child_order
    }
    pub fn clear_child_order(&mut self) {
        self.child_order.clear();
    }

    // Param is passed by value, moved
    pub fn set_child_order(&mut self, v: ::std::vec::Vec<i32>) {
        self.child_order = v;
    }

    // Mutable pointer to the field.
    pub fn mut_child_order(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.child_order
    }

    // Take field
    pub fn take_child_order(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.child_order, ::std::vec::Vec::new())
    }

    // int32 child_size = 2;


    pub fn get_child_size(&self) -> i32 {
        self.child_size
    }
    pub fn clear_child_size(&mut self) {
        self.child_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_child_size(&mut self, v: i32) {
        self.child_size = v;
    }

    // int32 min_prefix_length = 3;


    pub fn get_min_prefix_length(&self) -> i32 {
        self.min_prefix_length
    }
    pub fn clear_min_prefix_length(&mut self) {
        self.min_prefix_length = 0;
    }

    // Param is passed by value, moved
    pub fn set_min_prefix_length(&mut self, v: i32) {
        self.min_prefix_length = v;
    }

    // int32 max_prefix_length = 4;


    pub fn get_max_prefix_length(&self) -> i32 {
        self.max_prefix_length
    }
    pub fn clear_max_prefix_length(&mut self) {
        self.max_prefix_length = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_prefix_length(&mut self, v: i32) {
        self.max_prefix_length = v;
    }

    // bytes empty_child = 5;


    pub fn get_empty_child(&self) -> &[u8] {
        &self.empty_child
    }
    pub fn clear_empty_child(&mut self) {
        self.empty_child.clear();
    }

    // Param is passed by value, moved
    pub fn set_empty_child(&mut self, v: ::std::vec::Vec<u8>) {
        self.empty_child = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_empty_child(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.empty_child
    }

    // Take field
    pub fn take_empty_child(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.empty_child, ::std::vec::Vec::new())
    }

    // .ics23.HashOp hash = 6;


    pub fn get_hash(&self) -> HashOp {
        self.hash
    }
    pub fn clear_hash(&mut self) {
        self.hash = HashOp::NO_HASH;
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: HashOp) {
        self.hash = v;
    }
}

impl ::protobuf::Message for InnerSpec {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.child_order)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.child_size = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.min_prefix_length = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_prefix_length = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.empty_child)?;
                },
                6 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.hash, 6, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.child_order {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.child_size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.child_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.min_prefix_length != 0 {
            my_size += ::protobuf::rt::value_size(3, self.min_prefix_length, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_prefix_length != 0 {
            my_size += ::protobuf::rt::value_size(4, self.max_prefix_length, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.empty_child.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.empty_child);
        }
        if self.hash != HashOp::NO_HASH {
            my_size += ::protobuf::rt::enum_size(6, self.hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.child_order {
            os.write_int32(1, *v)?;
        };
        if self.child_size != 0 {
            os.write_int32(2, self.child_size)?;
        }
        if self.min_prefix_length != 0 {
            os.write_int32(3, self.min_prefix_length)?;
        }
        if self.max_prefix_length != 0 {
            os.write_int32(4, self.max_prefix_length)?;
        }
        if !self.empty_child.is_empty() {
            os.write_bytes(5, &self.empty_child)?;
        }
        if self.hash != HashOp::NO_HASH {
            os.write_enum(6, ::protobuf::ProtobufEnum::value(&self.hash))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InnerSpec {
        InnerSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "child_order",
                |m: &InnerSpec| { &m.child_order },
                |m: &mut InnerSpec| { &mut m.child_order },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "child_size",
                |m: &InnerSpec| { &m.child_size },
                |m: &mut InnerSpec| { &mut m.child_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "min_prefix_length",
                |m: &InnerSpec| { &m.min_prefix_length },
                |m: &mut InnerSpec| { &mut m.min_prefix_length },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "max_prefix_length",
                |m: &InnerSpec| { &m.max_prefix_length },
                |m: &mut InnerSpec| { &mut m.max_prefix_length },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "empty_child",
                |m: &InnerSpec| { &m.empty_child },
                |m: &mut InnerSpec| { &mut m.empty_child },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<HashOp>>(
                "hash",
                |m: &InnerSpec| { &m.hash },
                |m: &mut InnerSpec| { &mut m.hash },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InnerSpec>(
                "InnerSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InnerSpec {
        static instance: ::protobuf::rt::LazyV2<InnerSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InnerSpec::new)
    }
}

impl ::protobuf::Clear for InnerSpec {
    fn clear(&mut self) {
        self.child_order.clear();
        self.child_size = 0;
        self.min_prefix_length = 0;
        self.max_prefix_length = 0;
        self.empty_child.clear();
        self.hash = HashOp::NO_HASH;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InnerSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InnerSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BatchProof {
    // message fields
    pub entries: ::protobuf::RepeatedField<BatchEntry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BatchProof {
    fn default() -> &'a BatchProof {
        <BatchProof as ::protobuf::Message>::default_instance()
    }
}

impl BatchProof {
    pub fn new() -> BatchProof {
        ::std::default::Default::default()
    }

    // repeated .ics23.BatchEntry entries = 1;


    pub fn get_entries(&self) -> &[BatchEntry] {
        &self.entries
    }
    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::protobuf::RepeatedField<BatchEntry>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::protobuf::RepeatedField<BatchEntry> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::protobuf::RepeatedField<BatchEntry> {
        ::std::mem::replace(&mut self.entries, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for BatchProof {
    fn is_initialized(&self) -> bool {
        for v in &self.entries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entries)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.entries {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BatchProof {
        BatchProof::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BatchEntry>>(
                "entries",
                |m: &BatchProof| { &m.entries },
                |m: &mut BatchProof| { &mut m.entries },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BatchProof>(
                "BatchProof",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BatchProof {
        static instance: ::protobuf::rt::LazyV2<BatchProof> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BatchProof::new)
    }
}

impl ::protobuf::Clear for BatchProof {
    fn clear(&mut self) {
        self.entries.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BatchProof {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BatchProof {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BatchEntry {
    // message oneof groups
    pub proof: ::std::option::Option<BatchEntry_oneof_proof>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BatchEntry {
    fn default() -> &'a BatchEntry {
        <BatchEntry as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum BatchEntry_oneof_proof {
    exist(ExistenceProof),
    nonexist(NonExistenceProof),
}

impl BatchEntry {
    pub fn new() -> BatchEntry {
        ::std::default::Default::default()
    }

    // .ics23.ExistenceProof exist = 1;


    pub fn get_exist(&self) -> &ExistenceProof {
        match self.proof {
            ::std::option::Option::Some(BatchEntry_oneof_proof::exist(ref v)) => v,
            _ => <ExistenceProof as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_exist(&mut self) {
        self.proof = ::std::option::Option::None;
    }

    pub fn has_exist(&self) -> bool {
        match self.proof {
            ::std::option::Option::Some(BatchEntry_oneof_proof::exist(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_exist(&mut self, v: ExistenceProof) {
        self.proof = ::std::option::Option::Some(BatchEntry_oneof_proof::exist(v))
    }

    // Mutable pointer to the field.
    pub fn mut_exist(&mut self) -> &mut ExistenceProof {
        if let ::std::option::Option::Some(BatchEntry_oneof_proof::exist(_)) = self.proof {
        } else {
            self.proof = ::std::option::Option::Some(BatchEntry_oneof_proof::exist(ExistenceProof::new()));
        }
        match self.proof {
            ::std::option::Option::Some(BatchEntry_oneof_proof::exist(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_exist(&mut self) -> ExistenceProof {
        if self.has_exist() {
            match self.proof.take() {
                ::std::option::Option::Some(BatchEntry_oneof_proof::exist(v)) => v,
                _ => panic!(),
            }
        } else {
            ExistenceProof::new()
        }
    }

    // .ics23.NonExistenceProof nonexist = 2;


    pub fn get_nonexist(&self) -> &NonExistenceProof {
        match self.proof {
            ::std::option::Option::Some(BatchEntry_oneof_proof::nonexist(ref v)) => v,
            _ => <NonExistenceProof as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_nonexist(&mut self) {
        self.proof = ::std::option::Option::None;
    }

    pub fn has_nonexist(&self) -> bool {
        match self.proof {
            ::std::option::Option::Some(BatchEntry_oneof_proof::nonexist(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_nonexist(&mut self, v: NonExistenceProof) {
        self.proof = ::std::option::Option::Some(BatchEntry_oneof_proof::nonexist(v))
    }

    // Mutable pointer to the field.
    pub fn mut_nonexist(&mut self) -> &mut NonExistenceProof {
        if let ::std::option::Option::Some(BatchEntry_oneof_proof::nonexist(_)) = self.proof {
        } else {
            self.proof = ::std::option::Option::Some(BatchEntry_oneof_proof::nonexist(NonExistenceProof::new()));
        }
        match self.proof {
            ::std::option::Option::Some(BatchEntry_oneof_proof::nonexist(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_nonexist(&mut self) -> NonExistenceProof {
        if self.has_nonexist() {
            match self.proof.take() {
                ::std::option::Option::Some(BatchEntry_oneof_proof::nonexist(v)) => v,
                _ => panic!(),
            }
        } else {
            NonExistenceProof::new()
        }
    }
}

impl ::protobuf::Message for BatchEntry {
    fn is_initialized(&self) -> bool {
        if let Some(BatchEntry_oneof_proof::exist(ref v)) = self.proof {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(BatchEntry_oneof_proof::nonexist(ref v)) = self.proof {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.proof = ::std::option::Option::Some(BatchEntry_oneof_proof::exist(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.proof = ::std::option::Option::Some(BatchEntry_oneof_proof::nonexist(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.proof {
            match v {
                &BatchEntry_oneof_proof::exist(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &BatchEntry_oneof_proof::nonexist(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.proof {
            match v {
                &BatchEntry_oneof_proof::exist(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &BatchEntry_oneof_proof::nonexist(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BatchEntry {
        BatchEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ExistenceProof>(
                "exist",
                BatchEntry::has_exist,
                BatchEntry::get_exist,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, NonExistenceProof>(
                "nonexist",
                BatchEntry::has_nonexist,
                BatchEntry::get_nonexist,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BatchEntry>(
                "BatchEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BatchEntry {
        static instance: ::protobuf::rt::LazyV2<BatchEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BatchEntry::new)
    }
}

impl ::protobuf::Clear for BatchEntry {
    fn clear(&mut self) {
        self.proof = ::std::option::Option::None;
        self.proof = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BatchEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BatchEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CompressedBatchProof {
    // message fields
    pub entries: ::protobuf::RepeatedField<CompressedBatchEntry>,
    pub lookup_inners: ::protobuf::RepeatedField<InnerOp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CompressedBatchProof {
    fn default() -> &'a CompressedBatchProof {
        <CompressedBatchProof as ::protobuf::Message>::default_instance()
    }
}

impl CompressedBatchProof {
    pub fn new() -> CompressedBatchProof {
        ::std::default::Default::default()
    }

    // repeated .ics23.CompressedBatchEntry entries = 1;


    pub fn get_entries(&self) -> &[CompressedBatchEntry] {
        &self.entries
    }
    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::protobuf::RepeatedField<CompressedBatchEntry>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::protobuf::RepeatedField<CompressedBatchEntry> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::protobuf::RepeatedField<CompressedBatchEntry> {
        ::std::mem::replace(&mut self.entries, ::protobuf::RepeatedField::new())
    }

    // repeated .ics23.InnerOp lookup_inners = 2;


    pub fn get_lookup_inners(&self) -> &[InnerOp] {
        &self.lookup_inners
    }
    pub fn clear_lookup_inners(&mut self) {
        self.lookup_inners.clear();
    }

    // Param is passed by value, moved
    pub fn set_lookup_inners(&mut self, v: ::protobuf::RepeatedField<InnerOp>) {
        self.lookup_inners = v;
    }

    // Mutable pointer to the field.
    pub fn mut_lookup_inners(&mut self) -> &mut ::protobuf::RepeatedField<InnerOp> {
        &mut self.lookup_inners
    }

    // Take field
    pub fn take_lookup_inners(&mut self) -> ::protobuf::RepeatedField<InnerOp> {
        ::std::mem::replace(&mut self.lookup_inners, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CompressedBatchProof {
    fn is_initialized(&self) -> bool {
        for v in &self.entries {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.lookup_inners {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entries)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.lookup_inners)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.lookup_inners {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.entries {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.lookup_inners {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CompressedBatchProof {
        CompressedBatchProof::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CompressedBatchEntry>>(
                "entries",
                |m: &CompressedBatchProof| { &m.entries },
                |m: &mut CompressedBatchProof| { &mut m.entries },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InnerOp>>(
                "lookup_inners",
                |m: &CompressedBatchProof| { &m.lookup_inners },
                |m: &mut CompressedBatchProof| { &mut m.lookup_inners },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CompressedBatchProof>(
                "CompressedBatchProof",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CompressedBatchProof {
        static instance: ::protobuf::rt::LazyV2<CompressedBatchProof> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CompressedBatchProof::new)
    }
}

impl ::protobuf::Clear for CompressedBatchProof {
    fn clear(&mut self) {
        self.entries.clear();
        self.lookup_inners.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CompressedBatchProof {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CompressedBatchProof {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CompressedBatchEntry {
    // message oneof groups
    pub proof: ::std::option::Option<CompressedBatchEntry_oneof_proof>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CompressedBatchEntry {
    fn default() -> &'a CompressedBatchEntry {
        <CompressedBatchEntry as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum CompressedBatchEntry_oneof_proof {
    exist(CompressedExistenceProof),
    nonexist(CompressedNonExistenceProof),
}

impl CompressedBatchEntry {
    pub fn new() -> CompressedBatchEntry {
        ::std::default::Default::default()
    }

    // .ics23.CompressedExistenceProof exist = 1;


    pub fn get_exist(&self) -> &CompressedExistenceProof {
        match self.proof {
            ::std::option::Option::Some(CompressedBatchEntry_oneof_proof::exist(ref v)) => v,
            _ => <CompressedExistenceProof as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_exist(&mut self) {
        self.proof = ::std::option::Option::None;
    }

    pub fn has_exist(&self) -> bool {
        match self.proof {
            ::std::option::Option::Some(CompressedBatchEntry_oneof_proof::exist(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_exist(&mut self, v: CompressedExistenceProof) {
        self.proof = ::std::option::Option::Some(CompressedBatchEntry_oneof_proof::exist(v))
    }

    // Mutable pointer to the field.
    pub fn mut_exist(&mut self) -> &mut CompressedExistenceProof {
        if let ::std::option::Option::Some(CompressedBatchEntry_oneof_proof::exist(_)) = self.proof {
        } else {
            self.proof = ::std::option::Option::Some(CompressedBatchEntry_oneof_proof::exist(CompressedExistenceProof::new()));
        }
        match self.proof {
            ::std::option::Option::Some(CompressedBatchEntry_oneof_proof::exist(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_exist(&mut self) -> CompressedExistenceProof {
        if self.has_exist() {
            match self.proof.take() {
                ::std::option::Option::Some(CompressedBatchEntry_oneof_proof::exist(v)) => v,
                _ => panic!(),
            }
        } else {
            CompressedExistenceProof::new()
        }
    }

    // .ics23.CompressedNonExistenceProof nonexist = 2;


    pub fn get_nonexist(&self) -> &CompressedNonExistenceProof {
        match self.proof {
            ::std::option::Option::Some(CompressedBatchEntry_oneof_proof::nonexist(ref v)) => v,
            _ => <CompressedNonExistenceProof as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_nonexist(&mut self) {
        self.proof = ::std::option::Option::None;
    }

    pub fn has_nonexist(&self) -> bool {
        match self.proof {
            ::std::option::Option::Some(CompressedBatchEntry_oneof_proof::nonexist(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_nonexist(&mut self, v: CompressedNonExistenceProof) {
        self.proof = ::std::option::Option::Some(CompressedBatchEntry_oneof_proof::nonexist(v))
    }

    // Mutable pointer to the field.
    pub fn mut_nonexist(&mut self) -> &mut CompressedNonExistenceProof {
        if let ::std::option::Option::Some(CompressedBatchEntry_oneof_proof::nonexist(_)) = self.proof {
        } else {
            self.proof = ::std::option::Option::Some(CompressedBatchEntry_oneof_proof::nonexist(CompressedNonExistenceProof::new()));
        }
        match self.proof {
            ::std::option::Option::Some(CompressedBatchEntry_oneof_proof::nonexist(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_nonexist(&mut self) -> CompressedNonExistenceProof {
        if self.has_nonexist() {
            match self.proof.take() {
                ::std::option::Option::Some(CompressedBatchEntry_oneof_proof::nonexist(v)) => v,
                _ => panic!(),
            }
        } else {
            CompressedNonExistenceProof::new()
        }
    }
}

impl ::protobuf::Message for CompressedBatchEntry {
    fn is_initialized(&self) -> bool {
        if let Some(CompressedBatchEntry_oneof_proof::exist(ref v)) = self.proof {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CompressedBatchEntry_oneof_proof::nonexist(ref v)) = self.proof {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.proof = ::std::option::Option::Some(CompressedBatchEntry_oneof_proof::exist(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.proof = ::std::option::Option::Some(CompressedBatchEntry_oneof_proof::nonexist(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.proof {
            match v {
                &CompressedBatchEntry_oneof_proof::exist(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CompressedBatchEntry_oneof_proof::nonexist(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.proof {
            match v {
                &CompressedBatchEntry_oneof_proof::exist(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CompressedBatchEntry_oneof_proof::nonexist(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CompressedBatchEntry {
        CompressedBatchEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CompressedExistenceProof>(
                "exist",
                CompressedBatchEntry::has_exist,
                CompressedBatchEntry::get_exist,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CompressedNonExistenceProof>(
                "nonexist",
                CompressedBatchEntry::has_nonexist,
                CompressedBatchEntry::get_nonexist,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CompressedBatchEntry>(
                "CompressedBatchEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CompressedBatchEntry {
        static instance: ::protobuf::rt::LazyV2<CompressedBatchEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CompressedBatchEntry::new)
    }
}

impl ::protobuf::Clear for CompressedBatchEntry {
    fn clear(&mut self) {
        self.proof = ::std::option::Option::None;
        self.proof = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CompressedBatchEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CompressedBatchEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CompressedExistenceProof {
    // message fields
    pub key: ::std::vec::Vec<u8>,
    pub value: ::std::vec::Vec<u8>,
    pub leaf: ::protobuf::SingularPtrField<LeafOp>,
    pub path: ::std::vec::Vec<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CompressedExistenceProof {
    fn default() -> &'a CompressedExistenceProof {
        <CompressedExistenceProof as ::protobuf::Message>::default_instance()
    }
}

impl CompressedExistenceProof {
    pub fn new() -> CompressedExistenceProof {
        ::std::default::Default::default()
    }

    // bytes key = 1;


    pub fn get_key(&self) -> &[u8] {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.key, ::std::vec::Vec::new())
    }

    // bytes value = 2;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }

    // .ics23.LeafOp leaf = 3;


    pub fn get_leaf(&self) -> &LeafOp {
        self.leaf.as_ref().unwrap_or_else(|| <LeafOp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_leaf(&mut self) {
        self.leaf.clear();
    }

    pub fn has_leaf(&self) -> bool {
        self.leaf.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaf(&mut self, v: LeafOp) {
        self.leaf = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_leaf(&mut self) -> &mut LeafOp {
        if self.leaf.is_none() {
            self.leaf.set_default();
        }
        self.leaf.as_mut().unwrap()
    }

    // Take field
    pub fn take_leaf(&mut self) -> LeafOp {
        self.leaf.take().unwrap_or_else(|| LeafOp::new())
    }

    // repeated int32 path = 4;


    pub fn get_path(&self) -> &[i32] {
        &self.path
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::vec::Vec<i32>) {
        self.path = v;
    }

    // Mutable pointer to the field.
    pub fn mut_path(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.path, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CompressedExistenceProof {
    fn is_initialized(&self) -> bool {
        for v in &self.leaf {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.leaf)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.value);
        }
        if let Some(ref v) = self.leaf.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.path {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_bytes(1, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(2, &self.value)?;
        }
        if let Some(ref v) = self.leaf.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.path {
            os.write_int32(4, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CompressedExistenceProof {
        CompressedExistenceProof::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "key",
                |m: &CompressedExistenceProof| { &m.key },
                |m: &mut CompressedExistenceProof| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "value",
                |m: &CompressedExistenceProof| { &m.value },
                |m: &mut CompressedExistenceProof| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LeafOp>>(
                "leaf",
                |m: &CompressedExistenceProof| { &m.leaf },
                |m: &mut CompressedExistenceProof| { &mut m.leaf },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "path",
                |m: &CompressedExistenceProof| { &m.path },
                |m: &mut CompressedExistenceProof| { &mut m.path },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CompressedExistenceProof>(
                "CompressedExistenceProof",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CompressedExistenceProof {
        static instance: ::protobuf::rt::LazyV2<CompressedExistenceProof> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CompressedExistenceProof::new)
    }
}

impl ::protobuf::Clear for CompressedExistenceProof {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.leaf.clear();
        self.path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CompressedExistenceProof {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CompressedExistenceProof {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CompressedNonExistenceProof {
    // message fields
    pub key: ::std::vec::Vec<u8>,
    pub left: ::protobuf::SingularPtrField<CompressedExistenceProof>,
    pub right: ::protobuf::SingularPtrField<CompressedExistenceProof>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CompressedNonExistenceProof {
    fn default() -> &'a CompressedNonExistenceProof {
        <CompressedNonExistenceProof as ::protobuf::Message>::default_instance()
    }
}

impl CompressedNonExistenceProof {
    pub fn new() -> CompressedNonExistenceProof {
        ::std::default::Default::default()
    }

    // bytes key = 1;


    pub fn get_key(&self) -> &[u8] {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.key, ::std::vec::Vec::new())
    }

    // .ics23.CompressedExistenceProof left = 2;


    pub fn get_left(&self) -> &CompressedExistenceProof {
        self.left.as_ref().unwrap_or_else(|| <CompressedExistenceProof as ::protobuf::Message>::default_instance())
    }
    pub fn clear_left(&mut self) {
        self.left.clear();
    }

    pub fn has_left(&self) -> bool {
        self.left.is_some()
    }

    // Param is passed by value, moved
    pub fn set_left(&mut self, v: CompressedExistenceProof) {
        self.left = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_left(&mut self) -> &mut CompressedExistenceProof {
        if self.left.is_none() {
            self.left.set_default();
        }
        self.left.as_mut().unwrap()
    }

    // Take field
    pub fn take_left(&mut self) -> CompressedExistenceProof {
        self.left.take().unwrap_or_else(|| CompressedExistenceProof::new())
    }

    // .ics23.CompressedExistenceProof right = 3;


    pub fn get_right(&self) -> &CompressedExistenceProof {
        self.right.as_ref().unwrap_or_else(|| <CompressedExistenceProof as ::protobuf::Message>::default_instance())
    }
    pub fn clear_right(&mut self) {
        self.right.clear();
    }

    pub fn has_right(&self) -> bool {
        self.right.is_some()
    }

    // Param is passed by value, moved
    pub fn set_right(&mut self, v: CompressedExistenceProof) {
        self.right = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_right(&mut self) -> &mut CompressedExistenceProof {
        if self.right.is_none() {
            self.right.set_default();
        }
        self.right.as_mut().unwrap()
    }

    // Take field
    pub fn take_right(&mut self) -> CompressedExistenceProof {
        self.right.take().unwrap_or_else(|| CompressedExistenceProof::new())
    }
}

impl ::protobuf::Message for CompressedNonExistenceProof {
    fn is_initialized(&self) -> bool {
        for v in &self.left {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.right {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.left)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.right)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.key);
        }
        if let Some(ref v) = self.left.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.right.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_bytes(1, &self.key)?;
        }
        if let Some(ref v) = self.left.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.right.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CompressedNonExistenceProof {
        CompressedNonExistenceProof::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "key",
                |m: &CompressedNonExistenceProof| { &m.key },
                |m: &mut CompressedNonExistenceProof| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CompressedExistenceProof>>(
                "left",
                |m: &CompressedNonExistenceProof| { &m.left },
                |m: &mut CompressedNonExistenceProof| { &mut m.left },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CompressedExistenceProof>>(
                "right",
                |m: &CompressedNonExistenceProof| { &m.right },
                |m: &mut CompressedNonExistenceProof| { &mut m.right },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CompressedNonExistenceProof>(
                "CompressedNonExistenceProof",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CompressedNonExistenceProof {
        static instance: ::protobuf::rt::LazyV2<CompressedNonExistenceProof> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CompressedNonExistenceProof::new)
    }
}

impl ::protobuf::Clear for CompressedNonExistenceProof {
    fn clear(&mut self) {
        self.key.clear();
        self.left.clear();
        self.right.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CompressedNonExistenceProof {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CompressedNonExistenceProof {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum HashOp {
    NO_HASH = 0,
    SHA256 = 1,
    SHA512 = 2,
    KECCAK = 3,
    RIPEMD160 = 4,
    BITCOIN = 5,
}

impl ::protobuf::ProtobufEnum for HashOp {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<HashOp> {
        match value {
            0 => ::std::option::Option::Some(HashOp::NO_HASH),
            1 => ::std::option::Option::Some(HashOp::SHA256),
            2 => ::std::option::Option::Some(HashOp::SHA512),
            3 => ::std::option::Option::Some(HashOp::KECCAK),
            4 => ::std::option::Option::Some(HashOp::RIPEMD160),
            5 => ::std::option::Option::Some(HashOp::BITCOIN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [HashOp] = &[
            HashOp::NO_HASH,
            HashOp::SHA256,
            HashOp::SHA512,
            HashOp::KECCAK,
            HashOp::RIPEMD160,
            HashOp::BITCOIN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<HashOp>("HashOp", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for HashOp {
}

impl ::std::default::Default for HashOp {
    fn default() -> Self {
        HashOp::NO_HASH
    }
}

impl ::protobuf::reflect::ProtobufValue for HashOp {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum LengthOp {
    NO_PREFIX = 0,
    VAR_PROTO = 1,
    VAR_RLP = 2,
    FIXED32_BIG = 3,
    FIXED32_LITTLE = 4,
    FIXED64_BIG = 5,
    FIXED64_LITTLE = 6,
    REQUIRE_32_BYTES = 7,
    REQUIRE_64_BYTES = 8,
}

impl ::protobuf::ProtobufEnum for LengthOp {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LengthOp> {
        match value {
            0 => ::std::option::Option::Some(LengthOp::NO_PREFIX),
            1 => ::std::option::Option::Some(LengthOp::VAR_PROTO),
            2 => ::std::option::Option::Some(LengthOp::VAR_RLP),
            3 => ::std::option::Option::Some(LengthOp::FIXED32_BIG),
            4 => ::std::option::Option::Some(LengthOp::FIXED32_LITTLE),
            5 => ::std::option::Option::Some(LengthOp::FIXED64_BIG),
            6 => ::std::option::Option::Some(LengthOp::FIXED64_LITTLE),
            7 => ::std::option::Option::Some(LengthOp::REQUIRE_32_BYTES),
            8 => ::std::option::Option::Some(LengthOp::REQUIRE_64_BYTES),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [LengthOp] = &[
            LengthOp::NO_PREFIX,
            LengthOp::VAR_PROTO,
            LengthOp::VAR_RLP,
            LengthOp::FIXED32_BIG,
            LengthOp::FIXED32_LITTLE,
            LengthOp::FIXED64_BIG,
            LengthOp::FIXED64_LITTLE,
            LengthOp::REQUIRE_32_BYTES,
            LengthOp::REQUIRE_64_BYTES,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<LengthOp>("LengthOp", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for LengthOp {
}

impl ::std::default::Default for LengthOp {
    fn default() -> Self {
        LengthOp::NO_PREFIX
    }
}

impl ::protobuf::reflect::ProtobufValue for LengthOp {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x13confio/proofs.proto\x12\x05ics23\"\x7f\n\x0eExistenceProof\x12\x10\
    \n\x03key\x18\x01\x20\x01(\x0cR\x03key\x12\x14\n\x05value\x18\x02\x20\
    \x01(\x0cR\x05value\x12!\n\x04leaf\x18\x03\x20\x01(\x0b2\r.ics23.LeafOpR\
    \x04leaf\x12\"\n\x04path\x18\x04\x20\x03(\x0b2\x0e.ics23.InnerOpR\x04pat\
    h\"}\n\x11NonExistenceProof\x12\x10\n\x03key\x18\x01\x20\x01(\x0cR\x03ke\
    y\x12)\n\x04left\x18\x02\x20\x01(\x0b2\x15.ics23.ExistenceProofR\x04left\
    \x12+\n\x05right\x18\x03\x20\x01(\x0b2\x15.ics23.ExistenceProofR\x05righ\
    t\"\xeb\x01\n\x0fCommitmentProof\x12-\n\x05exist\x18\x01\x20\x01(\x0b2\
    \x15.ics23.ExistenceProofH\0R\x05exist\x126\n\x08nonexist\x18\x02\x20\
    \x01(\x0b2\x18.ics23.NonExistenceProofH\0R\x08nonexist\x12)\n\x05batch\
    \x18\x03\x20\x01(\x0b2\x11.ics23.BatchProofH\0R\x05batch\x12=\n\ncompres\
    sed\x18\x04\x20\x01(\x0b2\x1b.ics23.CompressedBatchProofH\0R\ncompressed\
    B\x07\n\x05proof\"\xd0\x01\n\x06LeafOp\x12!\n\x04hash\x18\x01\x20\x01(\
    \x0e2\r.ics23.HashOpR\x04hash\x12.\n\x0bprehash_key\x18\x02\x20\x01(\x0e\
    2\r.ics23.HashOpR\nprehashKey\x122\n\rprehash_value\x18\x03\x20\x01(\x0e\
    2\r.ics23.HashOpR\x0cprehashValue\x12'\n\x06length\x18\x04\x20\x01(\x0e2\
    \x0f.ics23.LengthOpR\x06length\x12\x16\n\x06prefix\x18\x05\x20\x01(\x0cR\
    \x06prefix\"\\\n\x07InnerOp\x12!\n\x04hash\x18\x01\x20\x01(\x0e2\r.ics23\
    .HashOpR\x04hash\x12\x16\n\x06prefix\x18\x02\x20\x01(\x0cR\x06prefix\x12\
    \x16\n\x06suffix\x18\x03\x20\x01(\x0cR\x06suffix\"\xa2\x01\n\tProofSpec\
    \x12*\n\tleaf_spec\x18\x01\x20\x01(\x0b2\r.ics23.LeafOpR\x08leafSpec\x12\
    /\n\ninner_spec\x18\x02\x20\x01(\x0b2\x10.ics23.InnerSpecR\tinnerSpec\
    \x12\x1b\n\tmax_depth\x18\x03\x20\x01(\x05R\x08maxDepth\x12\x1b\n\tmin_d\
    epth\x18\x04\x20\x01(\x05R\x08minDepth\"\xe7\x01\n\tInnerSpec\x12\x1f\n\
    \x0bchild_order\x18\x01\x20\x03(\x05R\nchildOrder\x12\x1d\n\nchild_size\
    \x18\x02\x20\x01(\x05R\tchildSize\x12*\n\x11min_prefix_length\x18\x03\
    \x20\x01(\x05R\x0fminPrefixLength\x12*\n\x11max_prefix_length\x18\x04\
    \x20\x01(\x05R\x0fmaxPrefixLength\x12\x1f\n\x0bempty_child\x18\x05\x20\
    \x01(\x0cR\nemptyChild\x12!\n\x04hash\x18\x06\x20\x01(\x0e2\r.ics23.Hash\
    OpR\x04hash\"9\n\nBatchProof\x12+\n\x07entries\x18\x01\x20\x03(\x0b2\x11\
    .ics23.BatchEntryR\x07entries\"|\n\nBatchEntry\x12-\n\x05exist\x18\x01\
    \x20\x01(\x0b2\x15.ics23.ExistenceProofH\0R\x05exist\x126\n\x08nonexist\
    \x18\x02\x20\x01(\x0b2\x18.ics23.NonExistenceProofH\0R\x08nonexistB\x07\
    \n\x05proof\"\x82\x01\n\x14CompressedBatchProof\x125\n\x07entries\x18\
    \x01\x20\x03(\x0b2\x1b.ics23.CompressedBatchEntryR\x07entries\x123\n\rlo\
    okup_inners\x18\x02\x20\x03(\x0b2\x0e.ics23.InnerOpR\x0clookupInners\"\
    \x9a\x01\n\x14CompressedBatchEntry\x127\n\x05exist\x18\x01\x20\x01(\x0b2\
    \x1f.ics23.CompressedExistenceProofH\0R\x05exist\x12@\n\x08nonexist\x18\
    \x02\x20\x01(\x0b2\".ics23.CompressedNonExistenceProofH\0R\x08nonexistB\
    \x07\n\x05proof\"y\n\x18CompressedExistenceProof\x12\x10\n\x03key\x18\
    \x01\x20\x01(\x0cR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\x0cR\x05va\
    lue\x12!\n\x04leaf\x18\x03\x20\x01(\x0b2\r.ics23.LeafOpR\x04leaf\x12\x12\
    \n\x04path\x18\x04\x20\x03(\x05R\x04path\"\x9b\x01\n\x1bCompressedNonExi\
    stenceProof\x12\x10\n\x03key\x18\x01\x20\x01(\x0cR\x03key\x123\n\x04left\
    \x18\x02\x20\x01(\x0b2\x1f.ics23.CompressedExistenceProofR\x04left\x125\
    \n\x05right\x18\x03\x20\x01(\x0b2\x1f.ics23.CompressedExistenceProofR\
    \x05right*U\n\x06HashOp\x12\x0b\n\x07NO_HASH\x10\0\x12\n\n\x06SHA256\x10\
    \x01\x12\n\n\x06SHA512\x10\x02\x12\n\n\x06KECCAK\x10\x03\x12\r\n\tRIPEMD\
    160\x10\x04\x12\x0b\n\x07BITCOIN\x10\x05*\xab\x01\n\x08LengthOp\x12\r\n\
    \tNO_PREFIX\x10\0\x12\r\n\tVAR_PROTO\x10\x01\x12\x0b\n\x07VAR_RLP\x10\
    \x02\x12\x0f\n\x0bFIXED32_BIG\x10\x03\x12\x12\n\x0eFIXED32_LITTLE\x10\
    \x04\x12\x0f\n\x0bFIXED64_BIG\x10\x05\x12\x12\n\x0eFIXED64_LITTLE\x10\
    \x06\x12\x14\n\x10REQUIRE_32_BYTES\x10\x07\x12\x14\n\x10REQUIRE_64_BYTES\
    \x10\x08B\x1cZ\x1agithub.com/confio/ics23/goJ\xfdL\n\x07\x12\x05\0\0\xe9\
    \x01\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x02\x08\
    \r\n\x08\n\x01\x08\x12\x03\x03\01\n\t\n\x02\x08\x0b\x12\x03\x03\01\n\n\n\
    \x02\x05\0\x12\x04\x05\0\r\x01\n\n\n\x03\x05\0\x01\x12\x03\x05\x05\x0b\n\
    f\n\x04\x05\0\x02\0\x12\x03\x07\x04\x10\x1aY\x20NO_HASH\x20is\x20the\x20\
    default\x20if\x20no\x20data\x20passed.\x20Note\x20this\x20is\x20an\x20il\
    legal\x20argument\x20some\x20places.\n\n\x0c\n\x05\x05\0\x02\0\x01\x12\
    \x03\x07\x04\x0b\n\x0c\n\x05\x05\0\x02\0\x02\x12\x03\x07\x0e\x0f\n\x0b\n\
    \x04\x05\0\x02\x01\x12\x03\x08\x04\x0f\n\x0c\n\x05\x05\0\x02\x01\x01\x12\
    \x03\x08\x04\n\n\x0c\n\x05\x05\0\x02\x01\x02\x12\x03\x08\r\x0e\n\x0b\n\
    \x04\x05\0\x02\x02\x12\x03\t\x04\x0f\n\x0c\n\x05\x05\0\x02\x02\x01\x12\
    \x03\t\x04\n\n\x0c\n\x05\x05\0\x02\x02\x02\x12\x03\t\r\x0e\n\x0b\n\x04\
    \x05\0\x02\x03\x12\x03\n\x04\x0f\n\x0c\n\x05\x05\0\x02\x03\x01\x12\x03\n\
    \x04\n\n\x0c\n\x05\x05\0\x02\x03\x02\x12\x03\n\r\x0e\n\x0b\n\x04\x05\0\
    \x02\x04\x12\x03\x0b\x04\x12\n\x0c\n\x05\x05\0\x02\x04\x01\x12\x03\x0b\
    \x04\r\n\x0c\n\x05\x05\0\x02\x04\x02\x12\x03\x0b\x10\x11\n#\n\x04\x05\0\
    \x02\x05\x12\x03\x0c\x04\x10\"\x16\x20ripemd160(sha256(x))\n\n\x0c\n\x05\
    \x05\0\x02\x05\x01\x12\x03\x0c\x04\x0b\n\x0c\n\x05\x05\0\x02\x05\x02\x12\
    \x03\x0c\x0e\x0f\n\x83\x02\n\x02\x05\x01\x12\x04\x15\0(\x01\x1a\xf6\x01*\
    \nLengthOp\x20defines\x20how\x20to\x20process\x20the\x20key\x20and\x20va\
    lue\x20of\x20the\x20LeafOp\nto\x20include\x20length\x20information.\x20A\
    fter\x20encoding\x20the\x20length\x20with\x20the\x20given\nalgorithm,\
    \x20the\x20length\x20will\x20be\x20prepended\x20to\x20the\x20key\x20and\
    \x20value\x20bytes.\n(Each\x20one\x20with\x20it's\x20own\x20encoded\x20l\
    ength)\n\n\n\n\x03\x05\x01\x01\x12\x03\x15\x05\r\n6\n\x04\x05\x01\x02\0\
    \x12\x03\x17\x04\x12\x1a)\x20NO_PREFIX\x20don't\x20include\x20any\x20len\
    gth\x20info\n\n\x0c\n\x05\x05\x01\x02\0\x01\x12\x03\x17\x04\r\n\x0c\n\
    \x05\x05\x01\x02\0\x02\x12\x03\x17\x10\x11\nS\n\x04\x05\x01\x02\x01\x12\
    \x03\x19\x04\x12\x1aF\x20VAR_PROTO\x20uses\x20protobuf\x20(and\x20go-ami\
    no)\x20varint\x20encoding\x20of\x20the\x20length\n\n\x0c\n\x05\x05\x01\
    \x02\x01\x01\x12\x03\x19\x04\r\n\x0c\n\x05\x05\x01\x02\x01\x02\x12\x03\
    \x19\x10\x11\n:\n\x04\x05\x01\x02\x02\x12\x03\x1b\x04\x10\x1a-\x20VAR_RL\
    P\x20uses\x20rlp\x20int\x20encoding\x20of\x20the\x20length\n\n\x0c\n\x05\
    \x05\x01\x02\x02\x01\x12\x03\x1b\x04\x0b\n\x0c\n\x05\x05\x01\x02\x02\x02\
    \x12\x03\x1b\x0e\x0f\nU\n\x04\x05\x01\x02\x03\x12\x03\x1d\x04\x14\x1aH\
    \x20FIXED32_BIG\x20uses\x20big-endian\x20encoding\x20of\x20the\x20length\
    \x20as\x20a\x2032\x20bit\x20integer\n\n\x0c\n\x05\x05\x01\x02\x03\x01\
    \x12\x03\x1d\x04\x0f\n\x0c\n\x05\x05\x01\x02\x03\x02\x12\x03\x1d\x12\x13\
    \n[\n\x04\x05\x01\x02\x04\x12\x03\x1f\x04\x17\x1aN\x20FIXED32_LITTLE\x20\
    uses\x20little-endian\x20encoding\x20of\x20the\x20length\x20as\x20a\x203\
    2\x20bit\x20integer\n\n\x0c\n\x05\x05\x01\x02\x04\x01\x12\x03\x1f\x04\
    \x12\n\x0c\n\x05\x05\x01\x02\x04\x02\x12\x03\x1f\x15\x16\nU\n\x04\x05\
    \x01\x02\x05\x12\x03!\x04\x14\x1aH\x20FIXED64_BIG\x20uses\x20big-endian\
    \x20encoding\x20of\x20the\x20length\x20as\x20a\x2064\x20bit\x20integer\n\
    \n\x0c\n\x05\x05\x01\x02\x05\x01\x12\x03!\x04\x0f\n\x0c\n\x05\x05\x01\
    \x02\x05\x02\x12\x03!\x12\x13\n[\n\x04\x05\x01\x02\x06\x12\x03#\x04\x17\
    \x1aN\x20FIXED64_LITTLE\x20uses\x20little-endian\x20encoding\x20of\x20th\
    e\x20length\x20as\x20a\x2064\x20bit\x20integer\n\n\x0c\n\x05\x05\x01\x02\
    \x06\x01\x12\x03#\x04\x12\n\x0c\n\x05\x05\x01\x02\x06\x02\x12\x03#\x15\
    \x16\np\n\x04\x05\x01\x02\x07\x12\x03%\x04\x19\x1ac\x20REQUIRE_32_BYTES\
    \x20is\x20like\x20NONE,\x20but\x20will\x20fail\x20if\x20the\x20input\x20\
    is\x20not\x20exactly\x2032\x20bytes\x20(sha256\x20output)\n\n\x0c\n\x05\
    \x05\x01\x02\x07\x01\x12\x03%\x04\x14\n\x0c\n\x05\x05\x01\x02\x07\x02\
    \x12\x03%\x17\x18\np\n\x04\x05\x01\x02\x08\x12\x03'\x04\x19\x1ac\x20REQU\
    IRE_64_BYTES\x20is\x20like\x20NONE,\x20but\x20will\x20fail\x20if\x20the\
    \x20input\x20is\x20not\x20exactly\x2064\x20bytes\x20(sha512\x20output)\n\
    \n\x0c\n\x05\x05\x01\x02\x08\x01\x12\x03'\x04\x14\n\x0c\n\x05\x05\x01\
    \x02\x08\x02\x12\x03'\x17\x18\n\xe6\x07\n\x02\x04\0\x12\x04?\0D\x01\x1a\
    \xd9\x07*\nExistenceProof\x20takes\x20a\x20key\x20and\x20a\x20value\x20a\
    nd\x20a\x20set\x20of\x20steps\x20to\x20perform\x20on\x20it.\nThe\x20resu\
    lt\x20of\x20peforming\x20all\x20these\x20steps\x20will\x20provide\x20a\
    \x20\"root\x20hash\",\x20which\x20can\nbe\x20compared\x20to\x20the\x20va\
    lue\x20in\x20a\x20header.\n\nSince\x20it\x20is\x20computationally\x20inf\
    easible\x20to\x20produce\x20a\x20hash\x20collission\x20for\x20any\x20of\
    \x20the\x20used\ncryptographic\x20hash\x20functions,\x20if\x20someone\
    \x20can\x20provide\x20a\x20series\x20of\x20operations\x20to\x20transform\
    \na\x20given\x20key\x20and\x20value\x20into\x20a\x20root\x20hash\x20that\
    \x20matches\x20some\x20trusted\x20root,\x20these\x20key\x20and\x20values\
    \nmust\x20be\x20in\x20the\x20referenced\x20merkle\x20tree.\n\nThe\x20onl\
    y\x20possible\x20issue\x20is\x20maliablity\x20in\x20LeafOp,\x20such\x20a\
    s\x20providing\x20extra\x20prefix\x20data,\nwhich\x20should\x20be\x20con\
    trolled\x20by\x20a\x20spec.\x20Eg.\x20with\x20lengthOp\x20as\x20NONE,\np\
    refix\x20=\x20FOO,\x20key\x20=\x20BAR,\x20value\x20=\x20CHOICE\nand\npre\
    fix\x20=\x20F,\x20key\x20=\x20OOBAR,\x20value\x20=\x20CHOICE\nwould\x20p\
    roduce\x20the\x20same\x20value.\n\nWith\x20LengthOp\x20this\x20is\x20tri\
    cker\x20but\x20not\x20impossible.\x20Which\x20is\x20why\x20the\x20\"leaf\
    PrefixEqual\"\x20field\nin\x20the\x20ProofSpec\x20is\x20valuable\x20to\
    \x20prevent\x20this\x20mutability.\x20And\x20why\x20all\x20trees\x20shou\
    ld\nlength-prefix\x20the\x20data\x20before\x20hashing\x20it.\n\n\n\n\x03\
    \x04\0\x01\x12\x03?\x08\x16\n\x0b\n\x04\x04\0\x02\0\x12\x03@\x04\x12\n\r\
    \n\x05\x04\0\x02\0\x04\x12\x04@\x04?\x18\n\x0c\n\x05\x04\0\x02\0\x05\x12\
    \x03@\x04\t\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03@\n\r\n\x0c\n\x05\x04\0\
    \x02\0\x03\x12\x03@\x10\x11\n\x0b\n\x04\x04\0\x02\x01\x12\x03A\x04\x14\n\
    \r\n\x05\x04\0\x02\x01\x04\x12\x04A\x04@\x12\n\x0c\n\x05\x04\0\x02\x01\
    \x05\x12\x03A\x04\t\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03A\n\x0f\n\x0c\n\
    \x05\x04\0\x02\x01\x03\x12\x03A\x12\x13\n\x0b\n\x04\x04\0\x02\x02\x12\
    \x03B\x04\x14\n\r\n\x05\x04\0\x02\x02\x04\x12\x04B\x04A\x14\n\x0c\n\x05\
    \x04\0\x02\x02\x06\x12\x03B\x04\n\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03B\
    \x0b\x0f\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03B\x12\x13\n\x0b\n\x04\x04\
    \0\x02\x03\x12\x03C\x04\x1e\n\x0c\n\x05\x04\0\x02\x03\x04\x12\x03C\x04\
    \x0c\n\x0c\n\x05\x04\0\x02\x03\x06\x12\x03C\r\x14\n\x0c\n\x05\x04\0\x02\
    \x03\x01\x12\x03C\x15\x19\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03C\x1c\x1d\
    \n\xdc\x01\n\x02\x04\x01\x12\x04K\0O\x01\x1a\xcf\x01\nNonExistenceProof\
    \x20takes\x20a\x20proof\x20of\x20two\x20neighbors,\x20one\x20left\x20of\
    \x20the\x20desired\x20key,\none\x20right\x20of\x20the\x20desired\x20key.\
    \x20If\x20both\x20proofs\x20are\x20valid\x20AND\x20they\x20are\x20neighb\
    ors,\nthen\x20there\x20is\x20no\x20valid\x20proof\x20for\x20the\x20given\
    \x20key.\n\n\n\n\x03\x04\x01\x01\x12\x03K\x08\x19\nC\n\x04\x04\x01\x02\0\
    \x12\x03L\x04\x12\"6\x20TODO:\x20remove\x20this\x20as\x20unnecessary???\
    \x20we\x20prove\x20a\x20range\n\n\r\n\x05\x04\x01\x02\0\x04\x12\x04L\x04\
    K\x1b\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03L\x04\t\n\x0c\n\x05\x04\x01\
    \x02\0\x01\x12\x03L\n\r\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03L\x10\x11\n\
    \x0b\n\x04\x04\x01\x02\x01\x12\x03M\x04\x1c\n\r\n\x05\x04\x01\x02\x01\
    \x04\x12\x04M\x04L\x12\n\x0c\n\x05\x04\x01\x02\x01\x06\x12\x03M\x04\x12\
    \n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03M\x13\x17\n\x0c\n\x05\x04\x01\
    \x02\x01\x03\x12\x03M\x1a\x1b\n\x0b\n\x04\x04\x01\x02\x02\x12\x03N\x04\
    \x1d\n\r\n\x05\x04\x01\x02\x02\x04\x12\x04N\x04M\x1c\n\x0c\n\x05\x04\x01\
    \x02\x02\x06\x12\x03N\x04\x12\n\x0c\n\x05\x04\x01\x02\x02\x01\x12\x03N\
    \x13\x18\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03N\x1b\x1c\nm\n\x02\x04\
    \x02\x12\x04T\0[\x01\x1aa\nCommitmentProof\x20is\x20either\x20an\x20Exis\
    tenceProof\x20or\x20a\x20NonExistenceProof,\x20or\x20a\x20Batch\x20of\
    \x20such\x20messages\n\n\n\n\x03\x04\x02\x01\x12\x03T\x08\x17\n\x0c\n\
    \x04\x04\x02\x08\0\x12\x04U\x04Z\x05\n\x0c\n\x05\x04\x02\x08\0\x01\x12\
    \x03U\n\x0f\n\x0b\n\x04\x04\x02\x02\0\x12\x03V\x08!\n\x0c\n\x05\x04\x02\
    \x02\0\x06\x12\x03V\x08\x16\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03V\x17\
    \x1c\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03V\x1f\x20\n\x0b\n\x04\x04\x02\
    \x02\x01\x12\x03W\x08'\n\x0c\n\x05\x04\x02\x02\x01\x06\x12\x03W\x08\x19\
    \n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03W\x1a\"\n\x0c\n\x05\x04\x02\x02\
    \x01\x03\x12\x03W%&\n\x0b\n\x04\x04\x02\x02\x02\x12\x03X\x08\x1d\n\x0c\n\
    \x05\x04\x02\x02\x02\x06\x12\x03X\x08\x12\n\x0c\n\x05\x04\x02\x02\x02\
    \x01\x12\x03X\x13\x18\n\x0c\n\x05\x04\x02\x02\x02\x03\x12\x03X\x1b\x1c\n\
    \x0b\n\x04\x04\x02\x02\x03\x12\x03Y\x08,\n\x0c\n\x05\x04\x02\x02\x03\x06\
    \x12\x03Y\x08\x1c\n\x0c\n\x05\x04\x02\x02\x03\x01\x12\x03Y\x1d'\n\x0c\n\
    \x05\x04\x02\x02\x03\x03\x12\x03Y*+\n\xc9\x04\n\x02\x04\x03\x12\x04m\0u\
    \x01\x1a\xbc\x04*\nLeafOp\x20represents\x20the\x20raw\x20key-value\x20da\
    ta\x20we\x20wish\x20to\x20prove,\x20and\nmust\x20be\x20flexible\x20to\
    \x20represent\x20the\x20internal\x20transformation\x20from\nthe\x20origi\
    nal\x20key-value\x20pairs\x20into\x20the\x20basis\x20hash,\x20for\x20man\
    y\x20existing\nmerkle\x20trees.\n\nkey\x20and\x20value\x20are\x20passed\
    \x20in.\x20So\x20that\x20the\x20signature\x20of\x20this\x20operation\x20\
    is:\nleafOp(key,\x20value)\x20->\x20output\n\nTo\x20process\x20this,\x20\
    first\x20prehash\x20the\x20keys\x20and\x20values\x20if\x20needed\x20(ANY\
    \x20means\x20no\x20hash\x20in\x20this\x20case):\nhkey\x20=\x20prehashKey\
    (key)\nhvalue\x20=\x20prehashValue(value)\n\nThen\x20combine\x20the\x20b\
    ytes,\x20and\x20hash\x20it\noutput\x20=\x20hash(prefix\x20||\x20length(h\
    key)\x20||\x20hkey\x20||\x20length(hvalue)\x20||\x20hvalue)\n\n\n\n\x03\
    \x04\x03\x01\x12\x03m\x08\x0e\n\x0b\n\x04\x04\x03\x02\0\x12\x03n\x04\x14\
    \n\r\n\x05\x04\x03\x02\0\x04\x12\x04n\x04m\x10\n\x0c\n\x05\x04\x03\x02\0\
    \x06\x12\x03n\x04\n\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03n\x0b\x0f\n\x0c\
    \n\x05\x04\x03\x02\0\x03\x12\x03n\x12\x13\n\x0b\n\x04\x04\x03\x02\x01\
    \x12\x03o\x04\x1b\n\r\n\x05\x04\x03\x02\x01\x04\x12\x04o\x04n\x14\n\x0c\
    \n\x05\x04\x03\x02\x01\x06\x12\x03o\x04\n\n\x0c\n\x05\x04\x03\x02\x01\
    \x01\x12\x03o\x0b\x16\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03o\x19\x1a\n\
    \x0b\n\x04\x04\x03\x02\x02\x12\x03p\x04\x1d\n\r\n\x05\x04\x03\x02\x02\
    \x04\x12\x04p\x04o\x1b\n\x0c\n\x05\x04\x03\x02\x02\x06\x12\x03p\x04\n\n\
    \x0c\n\x05\x04\x03\x02\x02\x01\x12\x03p\x0b\x18\n\x0c\n\x05\x04\x03\x02\
    \x02\x03\x12\x03p\x1b\x1c\n\x0b\n\x04\x04\x03\x02\x03\x12\x03q\x04\x18\n\
    \r\n\x05\x04\x03\x02\x03\x04\x12\x04q\x04p\x1d\n\x0c\n\x05\x04\x03\x02\
    \x03\x06\x12\x03q\x04\x0c\n\x0c\n\x05\x04\x03\x02\x03\x01\x12\x03q\r\x13\
    \n\x0c\n\x05\x04\x03\x02\x03\x03\x12\x03q\x16\x17\n\x89\x01\n\x04\x04\
    \x03\x02\x04\x12\x03t\x04\x15\x1a|\x20prefix\x20is\x20a\x20fixed\x20byte\
    s\x20that\x20may\x20optionally\x20be\x20included\x20at\x20the\x20beginni\
    ng\x20to\x20differentiate\n\x20a\x20leaf\x20node\x20from\x20an\x20inner\
    \x20node.\n\n\r\n\x05\x04\x03\x02\x04\x04\x12\x04t\x04q\x18\n\x0c\n\x05\
    \x04\x03\x02\x04\x05\x12\x03t\x04\t\n\x0c\n\x05\x04\x03\x02\x04\x01\x12\
    \x03t\n\x10\n\x0c\n\x05\x04\x03\x02\x04\x03\x12\x03t\x13\x14\n\xe4\x05\n\
    \x02\x04\x04\x12\x06\x88\x01\0\x8c\x01\x01\x1a\xd5\x05*\nInnerOp\x20repr\
    esents\x20a\x20merkle-proof\x20step\x20that\x20is\x20not\x20a\x20leaf.\n\
    It\x20represents\x20concatenating\x20two\x20children\x20and\x20hashing\
    \x20them\x20to\x20provide\x20the\x20next\x20result.\n\nThe\x20result\x20\
    of\x20the\x20previous\x20step\x20is\x20passed\x20in,\x20so\x20the\x20sig\
    nature\x20of\x20this\x20op\x20is:\ninnerOp(child)\x20->\x20output\n\nThe\
    \x20result\x20of\x20applying\x20InnerOp\x20should\x20be:\noutput\x20=\
    \x20op.hash(op.prefix\x20||\x20child\x20||\x20op.suffix)\n\nwhere\x20the\
    \x20||\x20operator\x20is\x20concatenation\x20of\x20binary\x20data,\nand\
    \x20child\x20is\x20the\x20result\x20of\x20hashing\x20all\x20the\x20tree\
    \x20below\x20this\x20step.\n\nAny\x20special\x20data,\x20like\x20prepend\
    ing\x20child\x20with\x20the\x20length,\x20or\x20prepending\x20the\x20ent\
    ire\x20operation\x20with\nsome\x20value\x20to\x20differentiate\x20from\
    \x20leaf\x20nodes,\x20should\x20be\x20included\x20in\x20prefix\x20and\
    \x20suffix.\nIf\x20either\x20of\x20prefix\x20or\x20suffix\x20is\x20empty\
    ,\x20we\x20just\x20treat\x20it\x20as\x20an\x20empty\x20string\n\n\x0b\n\
    \x03\x04\x04\x01\x12\x04\x88\x01\x08\x0f\n\x0c\n\x04\x04\x04\x02\0\x12\
    \x04\x89\x01\x04\x14\n\x0f\n\x05\x04\x04\x02\0\x04\x12\x06\x89\x01\x04\
    \x88\x01\x11\n\r\n\x05\x04\x04\x02\0\x06\x12\x04\x89\x01\x04\n\n\r\n\x05\
    \x04\x04\x02\0\x01\x12\x04\x89\x01\x0b\x0f\n\r\n\x05\x04\x04\x02\0\x03\
    \x12\x04\x89\x01\x12\x13\n\x0c\n\x04\x04\x04\x02\x01\x12\x04\x8a\x01\x04\
    \x15\n\x0f\n\x05\x04\x04\x02\x01\x04\x12\x06\x8a\x01\x04\x89\x01\x14\n\r\
    \n\x05\x04\x04\x02\x01\x05\x12\x04\x8a\x01\x04\t\n\r\n\x05\x04\x04\x02\
    \x01\x01\x12\x04\x8a\x01\n\x10\n\r\n\x05\x04\x04\x02\x01\x03\x12\x04\x8a\
    \x01\x13\x14\n\x0c\n\x04\x04\x04\x02\x02\x12\x04\x8b\x01\x04\x15\n\x0f\n\
    \x05\x04\x04\x02\x02\x04\x12\x06\x8b\x01\x04\x8a\x01\x15\n\r\n\x05\x04\
    \x04\x02\x02\x05\x12\x04\x8b\x01\x04\t\n\r\n\x05\x04\x04\x02\x02\x01\x12\
    \x04\x8b\x01\n\x10\n\r\n\x05\x04\x04\x02\x02\x03\x12\x04\x8b\x01\x13\x14\
    \n\xbf\x04\n\x02\x04\x05\x12\x06\x9b\x01\0\xa4\x01\x01\x1a\xb0\x04*\nPro\
    ofSpec\x20defines\x20what\x20the\x20expected\x20parameters\x20are\x20for\
    \x20a\x20given\x20proof\x20type.\nThis\x20can\x20be\x20stored\x20in\x20t\
    he\x20client\x20and\x20used\x20to\x20validate\x20any\x20incoming\x20proo\
    fs.\n\nverify(ProofSpec,\x20Proof)\x20->\x20Proof\x20|\x20Error\n\nAs\
    \x20demonstrated\x20in\x20tests,\x20if\x20we\x20don't\x20fix\x20the\x20a\
    lgorithm\x20used\x20to\x20calculate\x20the\nLeafHash\x20for\x20a\x20give\
    n\x20tree,\x20there\x20are\x20many\x20possible\x20key-value\x20pairs\x20\
    that\x20can\ngenerate\x20a\x20given\x20hash\x20(by\x20interpretting\x20t\
    he\x20preimage\x20differently).\nWe\x20need\x20this\x20for\x20proper\x20\
    security,\x20requires\x20client\x20knows\x20a\x20priori\x20what\ntree\
    \x20format\x20server\x20uses.\x20But\x20not\x20in\x20code,\x20rather\x20\
    a\x20configuration\x20object.\n\n\x0b\n\x03\x04\x05\x01\x12\x04\x9b\x01\
    \x08\x11\n\xa0\x01\n\x04\x04\x05\x02\0\x12\x04\x9e\x01\x02\x17\x1a\x91\
    \x01\x20any\x20field\x20in\x20the\x20ExistenceProof\x20must\x20be\x20the\
    \x20same\x20as\x20in\x20this\x20spec.\n\x20except\x20Prefix,\x20which\
    \x20is\x20just\x20the\x20first\x20bytes\x20of\x20prefix\x20(spec\x20can\
    \x20be\x20longer)\x20\n\n\x0f\n\x05\x04\x05\x02\0\x04\x12\x06\x9e\x01\
    \x02\x9b\x01\x13\n\r\n\x05\x04\x05\x02\0\x06\x12\x04\x9e\x01\x02\x08\n\r\
    \n\x05\x04\x05\x02\0\x01\x12\x04\x9e\x01\t\x12\n\r\n\x05\x04\x05\x02\0\
    \x03\x12\x04\x9e\x01\x15\x16\n\x0c\n\x04\x04\x05\x02\x01\x12\x04\x9f\x01\
    \x02\x1b\n\x0f\n\x05\x04\x05\x02\x01\x04\x12\x06\x9f\x01\x02\x9e\x01\x17\
    \n\r\n\x05\x04\x05\x02\x01\x06\x12\x04\x9f\x01\x02\x0b\n\r\n\x05\x04\x05\
    \x02\x01\x01\x12\x04\x9f\x01\x0c\x16\n\r\n\x05\x04\x05\x02\x01\x03\x12\
    \x04\x9f\x01\x19\x1a\nk\n\x04\x04\x05\x02\x02\x12\x04\xa1\x01\x02\x16\
    \x1a]\x20max_depth\x20(if\x20>\x200)\x20is\x20the\x20maximum\x20number\
    \x20of\x20InnerOps\x20allowed\x20(mainly\x20for\x20fixed-depth\x20tries)\
    \n\n\x0f\n\x05\x04\x05\x02\x02\x04\x12\x06\xa1\x01\x02\x9f\x01\x1b\n\r\n\
    \x05\x04\x05\x02\x02\x05\x12\x04\xa1\x01\x02\x07\n\r\n\x05\x04\x05\x02\
    \x02\x01\x12\x04\xa1\x01\x08\x11\n\r\n\x05\x04\x05\x02\x02\x03\x12\x04\
    \xa1\x01\x14\x15\nk\n\x04\x04\x05\x02\x03\x12\x04\xa3\x01\x02\x16\x1a]\
    \x20min_depth\x20(if\x20>\x200)\x20is\x20the\x20minimum\x20number\x20of\
    \x20InnerOps\x20allowed\x20(mainly\x20for\x20fixed-depth\x20tries)\n\n\
    \x0f\n\x05\x04\x05\x02\x03\x04\x12\x06\xa3\x01\x02\xa1\x01\x16\n\r\n\x05\
    \x04\x05\x02\x03\x05\x12\x04\xa3\x01\x02\x07\n\r\n\x05\x04\x05\x02\x03\
    \x01\x12\x04\xa3\x01\x08\x11\n\r\n\x05\x04\x05\x02\x03\x03\x12\x04\xa3\
    \x01\x14\x15\n\xa4\x02\n\x02\x04\x06\x12\x06\xb0\x01\0\xbc\x01\x01\x1a\
    \x95\x02\nInnerSpec\x20contains\x20all\x20store-specific\x20structure\
    \x20info\x20to\x20determine\x20if\x20two\x20proofs\x20from\x20a\ngiven\
    \x20store\x20are\x20neighbors.\n\nThis\x20enables:\n\nisLeftMost(spec:\
    \x20InnerSpec,\x20op:\x20InnerOp)\nisRightMost(spec:\x20InnerSpec,\x20op\
    :\x20InnerOp)\nisLeftNeighbor(spec:\x20InnerSpec,\x20left:\x20InnerOp,\
    \x20right:\x20InnerOp)\n\n\x0b\n\x03\x04\x06\x01\x12\x04\xb0\x01\x08\x11\
    \n\xa2\x01\n\x04\x04\x06\x02\0\x12\x04\xb4\x01\x04#\x1a\x93\x01\x20Child\
    \x20order\x20is\x20the\x20ordering\x20of\x20the\x20children\x20node,\x20\
    must\x20count\x20from\x200\n\x20iavl\x20tree\x20is\x20[0,\x201]\x20(left\
    \x20then\x20right)\n\x20merk\x20is\x20[0,\x202,\x201]\x20(left,\x20right\
    ,\x20here)\n\n\r\n\x05\x04\x06\x02\0\x04\x12\x04\xb4\x01\x04\x0c\n\r\n\
    \x05\x04\x06\x02\0\x05\x12\x04\xb4\x01\r\x12\n\r\n\x05\x04\x06\x02\0\x01\
    \x12\x04\xb4\x01\x13\x1e\n\r\n\x05\x04\x06\x02\0\x03\x12\x04\xb4\x01!\"\
    \n\x0c\n\x04\x04\x06\x02\x01\x12\x04\xb5\x01\x04\x19\n\x0f\n\x05\x04\x06\
    \x02\x01\x04\x12\x06\xb5\x01\x04\xb4\x01#\n\r\n\x05\x04\x06\x02\x01\x05\
    \x12\x04\xb5\x01\x04\t\n\r\n\x05\x04\x06\x02\x01\x01\x12\x04\xb5\x01\n\
    \x14\n\r\n\x05\x04\x06\x02\x01\x03\x12\x04\xb5\x01\x17\x18\n\x0c\n\x04\
    \x04\x06\x02\x02\x12\x04\xb6\x01\x04\x20\n\x0f\n\x05\x04\x06\x02\x02\x04\
    \x12\x06\xb6\x01\x04\xb5\x01\x19\n\r\n\x05\x04\x06\x02\x02\x05\x12\x04\
    \xb6\x01\x04\t\n\r\n\x05\x04\x06\x02\x02\x01\x12\x04\xb6\x01\n\x1b\n\r\n\
    \x05\x04\x06\x02\x02\x03\x12\x04\xb6\x01\x1e\x1f\n\x0c\n\x04\x04\x06\x02\
    \x03\x12\x04\xb7\x01\x04\x20\n\x0f\n\x05\x04\x06\x02\x03\x04\x12\x06\xb7\
    \x01\x04\xb6\x01\x20\n\r\n\x05\x04\x06\x02\x03\x05\x12\x04\xb7\x01\x04\t\
    \n\r\n\x05\x04\x06\x02\x03\x01\x12\x04\xb7\x01\n\x1b\n\r\n\x05\x04\x06\
    \x02\x03\x03\x12\x04\xb7\x01\x1e\x1f\ng\n\x04\x04\x06\x02\x04\x12\x04\
    \xb9\x01\x04\x1a\x1aY\x20empty\x20child\x20is\x20the\x20prehash\x20image\
    \x20that\x20is\x20used\x20when\x20one\x20child\x20is\x20nil\x20(eg.\x202\
    0\x20bytes\x20of\x200)\n\n\x0f\n\x05\x04\x06\x02\x04\x04\x12\x06\xb9\x01\
    \x04\xb7\x01\x20\n\r\n\x05\x04\x06\x02\x04\x05\x12\x04\xb9\x01\x04\t\n\r\
    \n\x05\x04\x06\x02\x04\x01\x12\x04\xb9\x01\n\x15\n\r\n\x05\x04\x06\x02\
    \x04\x03\x12\x04\xb9\x01\x18\x19\nH\n\x04\x04\x06\x02\x05\x12\x04\xbb\
    \x01\x04\x14\x1a:\x20hash\x20is\x20the\x20algorithm\x20that\x20must\x20b\
    e\x20used\x20for\x20each\x20InnerOp\n\n\x0f\n\x05\x04\x06\x02\x05\x04\
    \x12\x06\xbb\x01\x04\xb9\x01\x1a\n\r\n\x05\x04\x06\x02\x05\x06\x12\x04\
    \xbb\x01\x04\n\n\r\n\x05\x04\x06\x02\x05\x01\x12\x04\xbb\x01\x0b\x0f\n\r\
    \n\x05\x04\x06\x02\x05\x03\x12\x04\xbb\x01\x12\x13\nT\n\x02\x04\x07\x12\
    \x06\xc1\x01\0\xc3\x01\x01\x1aF\nBatchProof\x20is\x20a\x20group\x20of\
    \x20multiple\x20proof\x20types\x20than\x20can\x20be\x20compressed\n\n\
    \x0b\n\x03\x04\x07\x01\x12\x04\xc1\x01\x08\x12\n\x0c\n\x04\x04\x07\x02\0\
    \x12\x04\xc2\x01\x02\"\n\r\n\x05\x04\x07\x02\0\x04\x12\x04\xc2\x01\x02\n\
    \n\r\n\x05\x04\x07\x02\0\x06\x12\x04\xc2\x01\x0b\x15\n\r\n\x05\x04\x07\
    \x02\0\x01\x12\x04\xc2\x01\x16\x1d\n\r\n\x05\x04\x07\x02\0\x03\x12\x04\
    \xc2\x01\x20!\nF\n\x02\x04\x08\x12\x06\xc6\x01\0\xcb\x01\x01\x1a8\x20Use\
    \x20BatchEntry\x20not\x20CommitmentProof,\x20to\x20avoid\x20recursion\n\
    \n\x0b\n\x03\x04\x08\x01\x12\x04\xc6\x01\x08\x12\n\x0e\n\x04\x04\x08\x08\
    \0\x12\x06\xc7\x01\x02\xca\x01\x03\n\r\n\x05\x04\x08\x08\0\x01\x12\x04\
    \xc7\x01\x08\r\n\x0c\n\x04\x04\x08\x02\0\x12\x04\xc8\x01\x04\x1d\n\r\n\
    \x05\x04\x08\x02\0\x06\x12\x04\xc8\x01\x04\x12\n\r\n\x05\x04\x08\x02\0\
    \x01\x12\x04\xc8\x01\x13\x18\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\xc8\x01\
    \x1b\x1c\n\x0c\n\x04\x04\x08\x02\x01\x12\x04\xc9\x01\x04#\n\r\n\x05\x04\
    \x08\x02\x01\x06\x12\x04\xc9\x01\x04\x15\n\r\n\x05\x04\x08\x02\x01\x01\
    \x12\x04\xc9\x01\x16\x1e\n\r\n\x05\x04\x08\x02\x01\x03\x12\x04\xc9\x01!\
    \"\n>\n\x02\x04\t\x12\x06\xd0\x01\0\xd3\x01\x0120*****\x20all\x20items\
    \x20here\x20are\x20compressed\x20forms\x20******\n\x0b\n\x03\x04\t\x01\
    \x12\x04\xd0\x01\x08\x1c\n\x0c\n\x04\x04\t\x02\0\x12\x04\xd1\x01\x02,\n\
    \r\n\x05\x04\t\x02\0\x04\x12\x04\xd1\x01\x02\n\n\r\n\x05\x04\t\x02\0\x06\
    \x12\x04\xd1\x01\x0b\x1f\n\r\n\x05\x04\t\x02\0\x01\x12\x04\xd1\x01\x20'\
    \n\r\n\x05\x04\t\x02\0\x03\x12\x04\xd1\x01*+\n\x0c\n\x04\x04\t\x02\x01\
    \x12\x04\xd2\x01\x02%\n\r\n\x05\x04\t\x02\x01\x04\x12\x04\xd2\x01\x02\n\
    \n\r\n\x05\x04\t\x02\x01\x06\x12\x04\xd2\x01\x0b\x12\n\r\n\x05\x04\t\x02\
    \x01\x01\x12\x04\xd2\x01\x13\x20\n\r\n\x05\x04\t\x02\x01\x03\x12\x04\xd2\
    \x01#$\nF\n\x02\x04\n\x12\x06\xd6\x01\0\xdb\x01\x01\x1a8\x20Use\x20Batch\
    Entry\x20not\x20CommitmentProof,\x20to\x20avoid\x20recursion\n\n\x0b\n\
    \x03\x04\n\x01\x12\x04\xd6\x01\x08\x1c\n\x0e\n\x04\x04\n\x08\0\x12\x06\
    \xd7\x01\x02\xda\x01\x03\n\r\n\x05\x04\n\x08\0\x01\x12\x04\xd7\x01\x08\r\
    \n\x0c\n\x04\x04\n\x02\0\x12\x04\xd8\x01\x04'\n\r\n\x05\x04\n\x02\0\x06\
    \x12\x04\xd8\x01\x04\x1c\n\r\n\x05\x04\n\x02\0\x01\x12\x04\xd8\x01\x1d\"\
    \n\r\n\x05\x04\n\x02\0\x03\x12\x04\xd8\x01%&\n\x0c\n\x04\x04\n\x02\x01\
    \x12\x04\xd9\x01\x04-\n\r\n\x05\x04\n\x02\x01\x06\x12\x04\xd9\x01\x04\
    \x1f\n\r\n\x05\x04\n\x02\x01\x01\x12\x04\xd9\x01\x20(\n\r\n\x05\x04\n\
    \x02\x01\x03\x12\x04\xd9\x01+,\n\x0c\n\x02\x04\x0b\x12\x06\xdd\x01\0\xe3\
    \x01\x01\n\x0b\n\x03\x04\x0b\x01\x12\x04\xdd\x01\x08\x20\n\x0c\n\x04\x04\
    \x0b\x02\0\x12\x04\xde\x01\x02\x10\n\x0f\n\x05\x04\x0b\x02\0\x04\x12\x06\
    \xde\x01\x02\xdd\x01\"\n\r\n\x05\x04\x0b\x02\0\x05\x12\x04\xde\x01\x02\
    \x07\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\xde\x01\x08\x0b\n\r\n\x05\x04\
    \x0b\x02\0\x03\x12\x04\xde\x01\x0e\x0f\n\x0c\n\x04\x04\x0b\x02\x01\x12\
    \x04\xdf\x01\x02\x12\n\x0f\n\x05\x04\x0b\x02\x01\x04\x12\x06\xdf\x01\x02\
    \xde\x01\x10\n\r\n\x05\x04\x0b\x02\x01\x05\x12\x04\xdf\x01\x02\x07\n\r\n\
    \x05\x04\x0b\x02\x01\x01\x12\x04\xdf\x01\x08\r\n\r\n\x05\x04\x0b\x02\x01\
    \x03\x12\x04\xdf\x01\x10\x11\n\x0c\n\x04\x04\x0b\x02\x02\x12\x04\xe0\x01\
    \x02\x12\n\x0f\n\x05\x04\x0b\x02\x02\x04\x12\x06\xe0\x01\x02\xdf\x01\x12\
    \n\r\n\x05\x04\x0b\x02\x02\x06\x12\x04\xe0\x01\x02\x08\n\r\n\x05\x04\x0b\
    \x02\x02\x01\x12\x04\xe0\x01\t\r\n\r\n\x05\x04\x0b\x02\x02\x03\x12\x04\
    \xe0\x01\x10\x11\nV\n\x04\x04\x0b\x02\x03\x12\x04\xe2\x01\x02\x1a\x1aH\
    \x20these\x20are\x20indexes\x20into\x20the\x20lookup_inners\x20table\x20\
    in\x20CompressedBatchProof\n\n\r\n\x05\x04\x0b\x02\x03\x04\x12\x04\xe2\
    \x01\x02\n\n\r\n\x05\x04\x0b\x02\x03\x05\x12\x04\xe2\x01\x0b\x10\n\r\n\
    \x05\x04\x0b\x02\x03\x01\x12\x04\xe2\x01\x11\x15\n\r\n\x05\x04\x0b\x02\
    \x03\x03\x12\x04\xe2\x01\x18\x19\n\x0c\n\x02\x04\x0c\x12\x06\xe5\x01\0\
    \xe9\x01\x01\n\x0b\n\x03\x04\x0c\x01\x12\x04\xe5\x01\x08#\nD\n\x04\x04\
    \x0c\x02\0\x12\x04\xe6\x01\x02\x10\"6\x20TODO:\x20remove\x20this\x20as\
    \x20unnecessary???\x20we\x20prove\x20a\x20range\n\n\x0f\n\x05\x04\x0c\
    \x02\0\x04\x12\x06\xe6\x01\x02\xe5\x01%\n\r\n\x05\x04\x0c\x02\0\x05\x12\
    \x04\xe6\x01\x02\x07\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\xe6\x01\x08\x0b\
    \n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\xe6\x01\x0e\x0f\n\x0c\n\x04\x04\x0c\
    \x02\x01\x12\x04\xe7\x01\x02$\n\x0f\n\x05\x04\x0c\x02\x01\x04\x12\x06\
    \xe7\x01\x02\xe6\x01\x10\n\r\n\x05\x04\x0c\x02\x01\x06\x12\x04\xe7\x01\
    \x02\x1a\n\r\n\x05\x04\x0c\x02\x01\x01\x12\x04\xe7\x01\x1b\x1f\n\r\n\x05\
    \x04\x0c\x02\x01\x03\x12\x04\xe7\x01\"#\n\x0c\n\x04\x04\x0c\x02\x02\x12\
    \x04\xe8\x01\x02%\n\x0f\n\x05\x04\x0c\x02\x02\x04\x12\x06\xe8\x01\x02\
    \xe7\x01$\n\r\n\x05\x04\x0c\x02\x02\x06\x12\x04\xe8\x01\x02\x1a\n\r\n\
    \x05\x04\x0c\x02\x02\x01\x12\x04\xe8\x01\x1b\x20\n\r\n\x05\x04\x0c\x02\
    \x02\x03\x12\x04\xe8\x01#$b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
